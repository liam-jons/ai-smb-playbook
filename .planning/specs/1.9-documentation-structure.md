# Spec 1.9 — Documentation Structure for AI-Readable Codebases

> **Phase 2 build agent:** Agent 4 — Developer Track Sections
> **Track:** Developer

## Purpose

This section teaches Phew!'s developers how to structure project documentation so that Claude (and any future AI tool) can navigate and use it effectively. It builds directly on Section 1.8's "map not encyclopedia" principle — CLAUDE.md is the map, and this section explains how to build the territory it maps to. The content is adapted from the OpenAI/Reddit approach to agent-first documentation, scaled down to be practical for a 10-person team that is new to structured AI workflows. The section must leave developers with a clear, achievable /docs structure, a practical understanding of why it matters, and a path to generating initial documentation using the gsd-codebase-mapper tool (covered in detail in Section 1.10).

## Source References

| File | Path | What to extract |
|------|------|-----------------|
| Doc structure suggestions | `.planning/source-context/suggestions-related-to-doc-structure.md` | PRIMARY SOURCE. The full OpenAI/Reddit approach: repository knowledge as system of record, structured docs/ directory, CLAUDE.md/AGENTS.md as map, progressive disclosure, doc-gardening agents, CI validation, agent legibility as the goal. Key concepts: "give the agent a map, not a 1,000-page instruction manual"; "from the agent's point of view, anything it can't access in-context effectively doesn't exist"; knowledge that lives in Slack/Google Docs/people's heads is invisible to the agent; push context into the repo; "boring" technologies are easier for agents to model. |
| Training summary | `.planning/source-context/phew-training-claude-code-and-qa-summary.md` | Training content on documentation: reference external documentation in docs folder, automatic architecture documentation generation, multi-file cross-reference analysis. |
| Initial thoughts | `.planning/source-context/phew-initial-thoughts-for-meeting-follow-up.md` | Topics: "Creating a documentation setup which is just for Claude (i.e., LLM-ready and optimised)" and "Using agents to document, and maintain documentation for codebase." |
| GSD mapper agent | `starter-kit/gsd-mapper/agent/gsd-codebase-mapper.md` | The codebase mapper agent definition: explores codebase for specific focus areas (tech, arch, quality, concerns) and writes structured documents. Produces 7 documents: STACK.md, INTEGRATIONS.md, ARCHITECTURE.md, STRUCTURE.md, CONVENTIONS.md, TESTING.md, CONCERNS.md. Templates for each document type. |
| GSD mapper command | `starter-kit/gsd-mapper/command/map-codebase.md` | The /gsd:map-codebase command: spawns 4 parallel agents to analyse existing codebase. Output lands in .planning/codebase/. Can run on brownfield codebases, refresh after changes, or onboard to unfamiliar code. |
| GSD mapper workflow | `starter-kit/gsd-mapper/workflow/map-codebase.md` | Orchestration workflow: check existing, create structure, spawn 4 parallel agents (tech, arch, quality, concerns), collect confirmations, verify output, commit, offer next steps. |
| App tech stack | `.planning/research/app-tech-stack.md` | UI component decisions: shadcn/ui components, Shiki for code highlighting, architecture conventions for build agents. |
| Frontend skills review | `.planning/research/frontend-skills-review.md` | Full design guidelines and Build Agent Checklist. |

## Content Outline

### 1. Why Documentation Structure Matters for AI

**Opening — the core problem:**

Present the key insight from the OpenAI/Reddit source as a clear, relatable statement:

> "From the agent's point of view, anything it can't access in-context effectively doesn't exist."

Unpack this for Phew!'s developers:
- Knowledge that lives in Slack threads, Google Docs, team meetings, or people's heads is invisible to Claude. It cannot access any of it.
- The only knowledge Claude can use is what exists in the repository: code, markdown files, configuration, schemas.
- This means documentation is not just for humans any more — it is a direct input to the quality of Claude's output.
- A well-documented codebase produces better AI-assisted code. A poorly-documented one produces guesswork.

**The practical implication:**
- If your team aligned on an architectural pattern in a Slack discussion last month, Claude does not know about it.
- If your auth system has a quirk that everyone on the team knows about but nobody has written down, Claude will not know about it.
- Every piece of undocumented tribal knowledge is a source of errors when Claude writes code.

**Calibrate for Phew!'s maturity:** Acknowledge that most teams do not have extensive documentation, and that is normal. The goal is not to document everything overnight — it is to build a lightweight structure that grows incrementally and pays for itself through better AI output.

### 2. The Recommended /docs Structure

Present the recommended structure. This is adapted from the OpenAI/Reddit approach but scaled down for a small team. The original source uses a much more elaborate structure with design docs, execution plans, product specs, etc. — for Phew!, focus on the five directories that provide the most value.

**The structure:**

```
docs/
├── architecture/        # System architecture, domain model, data flow
├── conventions/         # Coding standards, naming patterns, PR conventions
├── integrations/        # Third-party service documentation
├── schemas/             # Database schemas, API request/response schemas
└── references/          # LLM-ready external docs (llms.txt files)
```

**Present each directory in an expandable accordion with guidance on what goes inside:**

#### `docs/architecture/`

What to put here:
- System architecture overview: how the major parts of the system connect.
- Domain model: the key entities and their relationships.
- Data flow: how data moves through the system (request lifecycle, event flow, etc.).
- Deployment architecture: how the system is deployed, what infrastructure it uses.

Example files:
- `overview.md` — High-level architecture diagram (text-based, e.g., Mermaid) and description.
- `domain-model.md` — Key entities, their relationships, and business rules.
- `data-flow.md` — Request lifecycle from user action to database and back.

**What makes this useful for Claude:** When asked to add a new feature, Claude can read the architecture doc to understand where the new code should live, what patterns to follow, and how it connects to existing systems.

**What does NOT belong here:** Line-by-line code walkthroughs, implementation details that change frequently, or anything that duplicates what is already clear from reading the code itself.

#### `docs/conventions/`

What to put here:
- Coding standards: naming conventions, file structure rules, import ordering.
- PR conventions: commit message format, review process, branch naming.
- Pattern library: "when you need to do X, here is the pattern we use" with code examples.
- Error handling conventions: how errors are handled, logged, and surfaced.

Example files:
- `code-style.md` — Naming, formatting, import conventions.
- `patterns.md` — Recurring patterns with code examples (e.g., "how we write API endpoints", "how we handle authentication in services").
- `git-workflow.md` — Branching strategy, commit message format, PR process.

**What makes this useful for Claude:** Consistency. Instead of Claude guessing your conventions by reading a few files, it reads a clear specification and follows it everywhere.

#### `docs/integrations/`

What to put here:
- Documentation for each third-party service the project uses.
- API keys and how they are managed (not the keys themselves — the process).
- Common gotchas and workarounds for each integration.
- Rate limits, retry strategies, fallback behaviour.

Example files:
- `stripe.md` — How Stripe is integrated, which APIs are used, webhook handling, test mode setup.
- `sendgrid.md` — Email sending patterns, template IDs, environment-specific configuration.

**What makes this useful for Claude:** Third-party integrations are where hallucinations are most likely. Claude's training data may include outdated API signatures. Your integration docs tell Claude exactly how your project uses each service, with current API patterns.

#### `docs/schemas/`

What to put here:
- Database schemas: tables, columns, relationships, constraints.
- API schemas: request/response formats for your endpoints.
- Data dictionaries: what each field means in business terms.

Example files:
- `database.md` — All tables with their columns, types, and relationships. Can be generated from your ORM/migration files.
- `api-endpoints.md` — Each endpoint with its request/response shape and auth requirements.

**What makes this useful for Claude:** When writing database queries or API handlers, Claude can reference the actual schema instead of inferring it from code. This drastically reduces errors in data access code.

#### `docs/references/`

What to put here:
- LLM-ready documentation for external tools and frameworks (llms.txt files).
- Many popular frameworks now publish llms.txt or llms-full.txt files — condensed documentation designed for AI consumption.
- Local copies of critical external documentation that Claude needs to write correct code.

Example files:
- `nextjs-llms.txt` — LLM-ready Next.js documentation (downloaded from the framework's site).
- `supabase-llms.txt` — LLM-ready Supabase documentation.

**What makes this useful for Claude:** Claude's training data has a cutoff date. If your project uses a framework that has changed since that cutoff, an llms.txt file gives Claude current, accurate documentation to work with. The context7 MCP (covered in Section 1.14) can also fetch these dynamically, but local copies are available offline and cost no API calls.

**Note about llms.txt:** This is an emerging standard. Not every framework has one yet. When available, it is a significant quality improvement. When not available, you can create a condensed version from the official docs yourself, or use a tool to convert documentation pages into a single markdown file.

### 3. Progressive Disclosure: How CLAUDE.md and /docs Work Together

Explain the two-layer system clearly, building on Section 1.8's "map not encyclopedia" concept.

**The principle:**
- CLAUDE.md is loaded into context automatically at session start. It costs tokens. Keep it short.
- /docs files are NOT loaded automatically. Claude reads them on demand, when it needs them.
- CLAUDE.md tells Claude what exists and where to find it. /docs contains the actual detail.

**Present a visual or text-based flow diagram:**

```
Session starts
    ↓
Claude reads CLAUDE.md (~150 lines, loaded automatically)
    ↓
Claude understands: project overview, commands, architecture summary, key gotchas
    ↓
User asks: "Add a new API endpoint for user preferences"
    ↓
Claude reads docs/architecture/overview.md → understands where API routes live
Claude reads docs/conventions/patterns.md → follows existing endpoint pattern
Claude reads docs/schemas/api-endpoints.md → matches existing response format
Claude reads docs/integrations/stripe.md → (only if the feature touches Stripe)
    ↓
Claude writes code that fits the existing codebase
```

**The key insight:** Claude reads documentation on a need-to-know basis. A task about the frontend never loads the database schema doc. A task about authentication does not load the Stripe integration doc. This is efficient — the right information is available without crowding out the task.

**Contrast with the "everything in CLAUDE.md" approach:** If all of this were in a single file, every session would load all of it, consuming thousands of tokens of context that are irrelevant to most tasks, and Claude would have to sift through architecture docs to find the testing command.

### 4. Getting Started: From Zero to a Working /docs Structure

A practical, phased approach that does not require documenting everything at once.

**Phase 1 — Scaffold the structure (5 minutes):**

Create the directories. Even empty directories signal intent and give Claude a place to look.

```bash
mkdir -p docs/architecture docs/conventions docs/integrations docs/schemas docs/references
```

**Phase 2 — Generate initial documentation with the codebase mapper (30 minutes):**

The gsd-codebase-mapper (covered in detail in Section 1.10) can analyse your existing codebase and generate structured documents covering architecture, conventions, tech stack, integrations, testing patterns, and concerns. This gives you a substantial starting point without manual writing.

The mapper outputs seven documents to `.planning/codebase/`:
- ARCHITECTURE.md, STRUCTURE.md → move to `docs/architecture/`
- CONVENTIONS.md, TESTING.md → move to `docs/conventions/`
- INTEGRATIONS.md → move to `docs/integrations/`
- STACK.md → move to `docs/architecture/` (or keep as a top-level reference)
- CONCERNS.md → use for technical debt tracking

These are generated documents — review them, correct any inaccuracies, and they become your baseline.

**Cross-reference:** "For a complete guide to running the codebase mapper and using its output, see Section 1.10 — Codebase Mapping."

**Phase 3 — Add the high-value content first (1–2 hours over a week):**

Prioritise documentation by its impact on Claude's output quality:

1. **Conventions** — Write down your naming patterns, error handling approach, and one or two recurring code patterns with examples. This has the highest per-token impact because it applies to every task.
2. **Schemas** — If you have database tables, document them. If you have API endpoints, document the shapes. This prevents data-layer hallucinations.
3. **Integration gotchas** — For each third-party service, write down the non-obvious things: "Stripe webhooks use this signing secret", "SendGrid templates require these variables."
4. **Architecture overview** — A high-level "how the pieces fit together" document. Does not need to be detailed — just enough for Claude to understand where things live.

**Phase 4 — Maintain incrementally (ongoing):**

Documentation maintenance should not be a separate chore. Build it into normal work:
- When you fix a bug caused by undocumented behaviour, document the behaviour.
- When you add a new integration, add an integration doc.
- When you change a pattern, update the conventions doc.
- Use the /revise-claude-md command (Section 1.8) to capture session learnings.

### 5. Keeping Documentation Current: Maintenance Strategies

Present three levels of maintenance, from simplest to most sophisticated. Phew! should start with Level 1 and adopt further levels as they see value.

**Level 1 — Manual Updates (Start Here)**

The simplest approach: when you change something, update the docs. Include a team convention:
- PR checklist item: "If this change affects architecture, conventions, schemas, or integrations, update the relevant doc."
- Session habit: Run `/revise-claude-md` at the end of productive sessions to capture learnings.

**Level 2 — Agent-Driven Doc Gardening**

Use Claude itself to maintain documentation. Present a copyable prompt for a "doc gardening" session:

A periodic task (monthly, or before a major project phase) where you ask Claude to review your docs for staleness. Claude reads the code and the docs, identifies discrepancies, and proposes updates.

**Level 3 — CI-Based Verification (Advanced)**

The OpenAI/Reddit approach includes CI jobs that validate documentation is up to date, cross-linked, and structured correctly. For Phew!, this is aspirational — mention it as where the practice leads at scale, but do not present it as something they need to do now.

Briefly describe what CI-based doc verification looks like:
- A linter that checks all files referenced in CLAUDE.md actually exist.
- A check that schema docs match the actual database schema.
- A freshness check that flags docs not updated in the last N months.

**Recommendation for Phew!:** Start with Level 1. It costs nothing and provides immediate value. Move to Level 2 when the team is comfortable with the /docs structure. Level 3 is worth considering only when the documentation set is large enough to warrant automated checks.

### 6. What NOT to Document (Keeping It Lean)

Equally important as knowing what to document. Present as a clear list:

- **Obvious code structure** — If it is clear from reading the code, do not duplicate it in docs. The purpose of docs is to capture what the code does not tell you.
- **Generic programming advice** — "Use meaningful variable names" is not project documentation. Only document conventions specific to your project.
- **Frequently changing implementation details** — If a piece of code changes weekly, documenting its specifics creates maintenance burden. Document the pattern, not the instance.
- **Everything** — Completeness is not the goal. Impact is. A small set of accurate, useful docs beats a large set of stale, overwhelming docs.

**The litmus test:** Before writing a doc, ask: "If Claude reads this, will it produce better code on this project?" If yes, write it. If it is generic knowledge Claude already has from training, skip it.

## Interaction Design

### Components Used

| Component | Source | Usage |
|-----------|--------|-------|
| `Accordion` | shadcn/ui | Expanding each /docs subdirectory to show detailed guidance and example files |
| `Card` | shadcn/ui | Maintenance level comparison (Level 1/2/3) |
| `Alert` | shadcn/ui | Key principle callouts ("anything it can't access in-context doesn't exist"), cross-references to other sections |
| `Badge` | shadcn/ui | Labels on maintenance levels (Start Here, Intermediate, Advanced), phase labels |
| `Button` | shadcn/ui | Copy-to-clipboard on all code blocks, prompts, and scaffold commands |
| `Collapsible` | shadcn/ui | "What NOT to document" expanding examples |
| `CodeBlock` | Custom (react-shiki) | Directory structure, scaffold commands, doc gardening prompt, example file contents |
| `Separator` | shadcn/ui | Visual dividers between major sections |

### Layout

- **Mobile (< 640px):** Single column. Accordions for /docs directory breakdowns. Maintenance levels stack vertically. Flow diagram renders as a vertical list.
- **Tablet (640px–1023px):** Single column with wider code blocks. Maintenance level cards can sit side-by-side if space allows.
- **Desktop (1024px+):** Max content width 65ch for body text. Directory structure code blocks can extend wider. Maintenance levels in a three-column layout. The progressive disclosure flow diagram can use a more visual horizontal layout.

### Key Interactions

1. **Directory accordion** — Each /docs subdirectory (architecture, conventions, integrations, schemas, references) expands to show guidance, example files, and the "what makes this useful for Claude" explanation. Multiple can be open simultaneously (unlike Section 1.8's single-open accordion, here the user may want to compare directories).
2. **Progressive disclosure flow** — The text-based flow diagram showing how Claude reads CLAUDE.md then navigates to /docs. Present as a styled sequence of steps, not a code block.
3. **Getting Started phases** — Four phases presented as a stepper or numbered cards. Each phase is expandable with detailed instructions.
4. **Maintenance levels** — Three cards with clear visual hierarchy: Level 1 is highlighted as the starting point, Level 2 as the next step, Level 3 as advanced/aspirational.
5. **Copy buttons** — On the scaffold command, the doc gardening prompt, and any example file content.

### Animation / Motion

- Accordion expand/collapse: shadcn built-in animation.
- Phase stepper: subtle transition when expanding a phase.
- Copy button feedback: icon switches from Copy to Check for 2 seconds.
- Respect `prefers-reduced-motion` throughout.

## Copyable Content

### 1. Directory Scaffold Command

```bash
mkdir -p docs/architecture docs/conventions docs/integrations docs/schemas docs/references
```

### 2. Doc Gardening Prompt

A copyable prompt for running a documentation review session:

```
Review the documentation in /docs against the current codebase. For each doc file:
1. Check if the information is still accurate (compare against actual code).
2. Identify any gaps — things that exist in the code but are not documented.
3. Flag any stale content that no longer reflects reality.

Output a summary of what needs updating, then propose specific changes as diffs. Wait for my approval before making any edits.
```

### 3. CLAUDE.md Documentation Pointers Section

A copyable block that developers can add to their CLAUDE.md to point to their /docs directory:

```markdown
## Documentation

For deeper reference, see the `/docs` directory:

- `docs/architecture/` — System architecture, domain model, data flow
- `docs/conventions/` — Coding standards, naming patterns, PR conventions
- `docs/integrations/` — Third-party service documentation
- `docs/schemas/` — Database schemas, API request/response schemas
- `docs/references/` — LLM-ready external docs (llms.txt files)
```

### 4. Example Architecture Overview Doc

A starting-point template for `docs/architecture/overview.md`:

```markdown
# Architecture Overview

## System Type

[e.g., "Full-stack web application with React frontend and Node.js API backend"]

## High-Level Components

```
[Client Browser]
    ↓ HTTPS
[React Frontend] ← Static files served by [CDN/Vercel]
    ↓ API calls
[Node.js API Server]
    ↓ queries
[PostgreSQL Database]
    ↓ events
[Background Workers]
```

## Key Directories

| Directory | Purpose |
|-----------|---------|
| `src/frontend/` | React application |
| `src/api/` | API route handlers and middleware |
| `src/services/` | Business logic layer |
| `src/models/` | Database models and queries |
| `src/workers/` | Background job processors |

## Request Lifecycle

1. Browser sends request to API endpoint.
2. Middleware handles: CORS, authentication, rate limiting.
3. Route handler validates input (Zod schema).
4. Handler calls service layer for business logic.
5. Service layer queries database via model layer.
6. Response shaped and returned as JSON.

## Key Architectural Decisions

- **Monorepo:** Frontend and backend in a single repository for deployment simplicity.
- **Service layer:** All business logic lives in `src/services/`. Route handlers are thin — validate input, call service, return response.
- **No ORM:** Raw SQL with parameterised queries via `pg` library. Chosen for transparency and performance.

## See Also

- `docs/conventions/patterns.md` — Code patterns and conventions
- `docs/schemas/database.md` — Database schema
```

### 5. Example Conventions Doc

A starting-point template for `docs/conventions/code-style.md`:

```markdown
# Code Style Conventions

## Naming

| Element | Convention | Example |
|---------|-----------|---------|
| Files (components) | PascalCase | `UserProfile.tsx` |
| Files (utilities) | kebab-case | `format-date.ts` |
| Functions | camelCase | `getUserById()` |
| Constants | UPPER_SNAKE | `MAX_RETRY_COUNT` |
| Types/Interfaces | PascalCase | `UserProfile`, `ApiResponse` |
| Database columns | snake_case | `created_at`, `user_id` |

## Error Handling

- Services return `Result<T, Error>` types — never throw.
- Route handlers wrap service calls in try/catch as a safety net.
- All errors are logged with context (user ID, request ID, operation).
- User-facing error messages are generic. Detailed errors go to logs only.

## Import Order

1. Node.js built-ins (`fs`, `path`)
2. External packages (`express`, `zod`)
3. Internal absolute imports (`@/services/`, `@/utils/`)
4. Relative imports (`./helpers`, `../types`)

Blank line between each group.

## API Endpoint Pattern

Every API endpoint follows this structure:

```typescript
// src/api/routes/users.ts
import { z } from 'zod';
import { userService } from '@/services/user';

const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1),
});

export async function createUser(req: Request, res: Response) {
  const input = createUserSchema.parse(req.body);
  const result = await userService.create(input);
  return res.status(201).json(result);
}
```
```

## Two-Track Considerations

This is a **Developer track** section. General track users do not need to understand documentation structure for codebases.

**Cross-references to General track:**
- Section 1.2 (How Context Works) establishes the concept that Claude has limited context and must choose what to focus on. This section builds on that principle at the codebase level — documentation structure is how you ensure Claude focuses on the right information.

**Cross-references within Developer track:**
- Section 1.8 (CLAUDE.md Files) introduces the "map not encyclopedia" principle. This section expands it into the full /docs structure that CLAUDE.md points to. The build agent should include a brief recap of the principle with a link back to 1.8, but should not re-explain CLAUDE.md in detail.
- Section 1.10 (Codebase Mapping) covers the gsd-codebase-mapper tool that generates initial documentation. This section references it as the practical starting point for populating /docs, but the detailed walkthrough of the mapper tool itself is in 1.10.
- Section 1.15 (Codebase Auditing & Technical Debt) connects to the CONCERNS.md output from the mapper and the broader theme of keeping documentation current.
- Section 1.14 (Plugin Recommendations) covers the context7 MCP which can fetch llms.txt files dynamically — relevant to the /docs/references/ directory.

## Acceptance Criteria

1. The section opens with a clear, compelling explanation of why documentation structure matters for AI, using the "anything it can't access in-context doesn't exist" principle as the anchor.
2. The recommended /docs structure is presented with all five directories (architecture, conventions, integrations, schemas, references), each with clear guidance on what belongs inside and example files.
3. Each directory's explanation includes a "What makes this useful for Claude" paragraph that concretely explains how this documentation improves AI output.
4. The progressive disclosure principle is explained clearly, showing how CLAUDE.md and /docs work as a two-layer system. A visual or text-based flow demonstrates Claude reading CLAUDE.md then navigating to specific docs as needed.
5. The "Getting Started" section provides a realistic, phased approach: scaffold (5 min), generate with mapper (30 min), add high-value content (1–2 hours over a week), maintain incrementally.
6. The three maintenance levels (Manual, Agent-Driven, CI-Based) are presented with clear recommendations: start with Level 1, adopt Level 2 when comfortable, Level 3 is aspirational.
7. The doc gardening prompt is provided as a copyable, immediately usable prompt.
8. The "What NOT to document" section is present and helps developers avoid over-documentation.
9. Cross-references to Section 1.8 (CLAUDE.md), Section 1.10 (Codebase Mapping), and Section 1.14 (Plugin Recommendations — context7) are clearly included.
10. The scaffold command (`mkdir -p docs/...`) is copyable with a copy-to-clipboard button.
11. The CLAUDE.md documentation pointers block is provided as a copyable snippet developers can paste directly into their CLAUDE.md.
12. Example templates for `docs/architecture/overview.md` and `docs/conventions/code-style.md` are provided as copyable starting points.
13. The content is scaled to Phew!'s maturity — practical and achievable for a 10-person team, not an enterprise documentation programme. The tone avoids making developers feel behind; it positions this as an incremental improvement, not a massive undertaking.
14. The llms.txt concept is explained clearly, noting it is an emerging standard, with guidance on where to find them and what to do when they are not available.
15. All code blocks use syntax highlighting (Shiki via react-shiki) with appropriate language tags (bash, markdown, typescript).
16. All body text uses UK English spelling and grammar.
17. The page is fully responsive with all content accessible on mobile.
18. Keyboard navigation works for all interactive elements (accordions, collapsibles, copy buttons).

## Build Agent Checklist

### Frontend Quality Checklist

**Typography**
- [ ] Body text >= 16px (1rem), using rem units
- [ ] Max line length: 65ch for body text
- [ ] Fluid type (clamp) on headings; fixed sizes on UI controls
- [ ] Font stacks include size-adjusted fallback
- [ ] No generic fonts (Inter, Roboto, etc.) unless explicitly specified

**Colour & Theming**
- [ ] All custom colours defined in OKLCH via CSS variables
- [ ] Neutrals tinted towards brand hue (not pure grey)
- [ ] No pure black (#000) or pure white (#fff)
- [ ] Dark mode tested and functional (if applicable to section)
- [ ] All text meets WCAG AA contrast (4.5:1 body, 3:1 large/UI)

**Layout & Spacing**
- [ ] Spacing values from the 4pt grid (4, 8, 12, 16, 24, 32, 48, 64, 96)
- [ ] Visual hierarchy uses 2+ dimensions (size, weight, colour, space)
- [ ] No nested cards
- [ ] No identical repeating card grids

**Motion & Animation**
- [ ] Only `transform` and `opacity` animated (no width/height/top/left)
- [ ] Timing follows 100/300/500 rule
- [ ] Easing uses exponential curves (not default `ease` or bounce)
- [ ] `prefers-reduced-motion` handled (crossfade fallback or disable)
- [ ] Exit animations faster than entrances
- [ ] Motion used via Tailwind transitions where CSS suffices; Motion library only for layout/enter/exit

**Interaction**
- [ ] All 8 interactive states designed (default, hover, focus, active, disabled, loading, error, success)
- [ ] `:focus-visible` ring on all interactive elements (2-3px, offset, 3:1 contrast)
- [ ] Touch targets >= 44px
- [ ] Copy-to-clipboard on every prompt/template/code block
- [ ] Skeleton screens for loading states (not generic spinners)

**Accessibility**
- [ ] Semantic HTML (headings, landmarks, labels)
- [ ] Skip link present
- [ ] Keyboard navigation tested (Tab, Enter, Escape, Arrows)
- [ ] `aria-expanded`, `aria-controls` on accordions/collapsibles
- [ ] `aria-label` on icon-only buttons
- [ ] Images have `alt` text (or `alt=""` for decorative)
- [ ] Never `outline: none` without `:focus-visible` replacement

**Performance**
- [ ] No barrel file imports (direct imports from source)
- [ ] Shiki lazy-loaded (not in initial bundle)
- [ ] Derived state computed during render (no useEffect for derived values)
- [ ] `content-visibility: auto` on long scrollable content
- [ ] Passive event listeners on scroll/touch handlers
- [ ] Static JSX hoisted outside components where possible

**Responsive**
- [ ] Mobile-first (base styles for mobile, min-width queries for larger)
- [ ] Tested at 320px, 640px, 768px, 1024px widths
- [ ] No critical functionality hidden on mobile
- [ ] Hover-dependent features have touch alternatives
- [ ] Safe area insets handled for mobile

**UX Writing & Content**
- [ ] UK English throughout (spelling, grammar, currency, date format)
- [ ] Button labels use verb + object pattern
- [ ] Error messages answer: what, why, how to fix
- [ ] Consistent terminology (no synonyms for the same action)
- [ ] Empty states are actionable, not just "Nothing here"

**Code Quality**
- [ ] Tailwind utility classes only (no CSS modules or styled-components)
- [ ] `cn()` utility for conditional class merging
- [ ] `@/` path alias for all imports
- [ ] Components composed from shadcn primitives (not mega-components)
- [ ] Content defined as typed TS objects, not hard-coded JSX
