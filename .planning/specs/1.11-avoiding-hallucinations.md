# Spec 1.11 — Avoiding Hallucinations & Quick-Fix Behaviour

> **Phase 2 build agent:** Agent 4 — Developer Track Sections
> **Track:** Developer (with cross-track callouts noted below)

## Purpose

This section equips Phew!'s development team with practical patterns for preventing two of the most common problems when using Claude for real development work: hallucinated code/APIs/configurations, and the "quick fix" tendency where Claude applies band-aid patches rather than addressing root causes. These patterns were discussed during the Claude Code and QA training session on 11 Feb 2026, and are drawn from the initial-thoughts document's section on "Patterns for avoiding hallucinations and quick-fix behaviour."

The section is deliberately prompt-heavy. Each anti-hallucination pattern is explained briefly, then demonstrated with a real, copyable prompt example contextualised for Phew!'s actual tech stack (WordPress, ASP.NET/C#, safeguarding compliance, ISO-certified processes). The goal is not theory — it is a set of immediately usable prompts that developers can copy and adapt.

The section also introduces the "agent harness" concept for structured optimisation workflows, tying together several of the individual patterns into a coherent methodology for larger tasks.

## Source References

| File | Path | What to extract |
|------|------|-----------------|
| Initial thoughts | `.planning/source-context/phew-initial-thoughts-for-meeting-follow-up.md` | PRIMARY SOURCE. The list of anti-hallucination patterns: breaking tasks down, planning, creating specs, asking for recommendations/options, prioritising best practice, giving an "out", outlining open questions before implementing. Also the agent harness concept. |
| Training summary (dev session) | `.planning/source-context/phew-training-claude-code-and-qa-summary.md` | Training content on workflow optimisation: "breaking complex tasks into atomic components", "each subtask gets full 200k token allocation", "prevents AI from defaulting to quick fix solutions", the agent harness concept for structured optimisation. |
| App tech stack | `.planning/research/app-tech-stack.md` | UI component decisions: shadcn/ui (Card, Accordion, Badge, Alert, Collapsible), copy-to-clipboard pattern, Shiki syntax highlighting via react-shiki, Motion for layout animations. |
| Frontend skills review | `.planning/research/frontend-skills-review.md` | Design guidelines, accessibility requirements, interaction states, responsive design rules, and the full Build Agent Checklist (copied in full at the end of this spec). |
| Handoff doc | `.planning/phew-follow-up-handoff.md` | Section 1.11 definition, Agent 4 assignment, coverage checklist mapping. |

## Content Outline

This section presents seven distinct anti-hallucination patterns, followed by the agent harness concept that synthesises several patterns into a structured methodology.

### Pattern 1: Break Tasks into Atomic Components

**Explanation:** Claude performs best when given focused, well-scoped tasks. Large, ambiguous requests ("refactor this whole module") invite hallucinated approaches because Claude tries to handle too many decisions at once. Breaking work into atomic subtasks means each task gets Claude's full 200k token context window, and each output is small enough to review meaningfully.

**When to use:** Any task that involves more than one file, more than one logical concern, or more than roughly 100 lines of change.

**Cross-track note:** This pattern applies equally to General users — breaking a long document into sections, handling one email at a time, or asking Claude to tackle one aspect of a problem before moving to the next. Note this with a Badge component ("Also useful for General users").

**Copyable prompt example (contextualised for Phew!):**

```
I need to migrate the safeguarding audit form from the legacy ASP.NET Web Forms page to a Razor Pages implementation.

Before writing any code, break this into a numbered list of atomic subtasks. Each subtask should:
- Change no more than 2-3 files
- Have a single clear objective
- Be independently testable

List the subtasks in dependency order. Do not implement anything yet.
```

### Pattern 2: Plan Before Implementing

**Explanation:** Asking Claude to plan before coding forces it to reason about the approach, surface assumptions, and reveal potential issues before any code is written. This is the single most effective pattern for avoiding quick-fix behaviour — Claude cannot take shortcuts if it has to articulate its strategy first.

**When to use:** Every non-trivial development task. Make it a habit to ask for a plan before any implementation.

**Cross-track note:** Highly relevant to General users as well — asking Claude to outline its approach before writing a document, drafting an email, or producing any substantial output. Note with Badge.

**Copyable prompt example:**

```
I want to add role-based access control to the LMS admin dashboard. Before writing any code, create a plan that covers:

1. What changes are needed and where (list specific files)
2. Your recommended approach and why
3. Any assumptions you are making
4. What could go wrong or what edge cases should we handle
5. What you would need to verify before implementing

Do not write any code yet. Present the plan and wait for my feedback.
```

### Pattern 3: Ask for Recommendations and Options

**Explanation:** Instead of asking Claude to implement a solution directly, ask it to present 2-3 options with trade-offs. This forces Claude to consider alternatives rather than jumping to the first approach it generates — which is often a hallucinated "obvious" solution that does not account for the specific codebase.

**When to use:** Architecture decisions, library choices, refactoring approaches, database schema changes, or any decision with multiple valid paths.

**Copyable prompt example:**

```
We need to implement automated email notifications for overdue safeguarding training in the LMS. Our stack is ASP.NET/C# with SQL Server.

Present 2-3 different approaches for the notification system. For each option, include:
- How it works (brief technical description)
- Pros and cons
- Estimated complexity (low / medium / high)
- Any dependencies or infrastructure requirements

Do not recommend one yet — just present the options so I can evaluate them.
```

### Pattern 4: Prioritise Best Practice

**Explanation:** Claude will match the quality bar you set. If you accept quick fixes, you get quick fixes. Explicitly stating that you want best-practice solutions — and naming the specific standards that matter — steers Claude away from hacky workarounds and towards maintainable code.

**When to use:** Whenever you are working on production code, especially in areas with compliance implications (safeguarding data handling, authentication, data protection).

**Copyable prompt example:**

```
I need to update the user authentication flow in our ASP.NET application. Requirements:

- Follow current ASP.NET Core Identity best practices
- Must comply with OWASP authentication guidelines
- We hold ISO 27001 certification, so security patterns must be auditable
- Prioritise maintainability over cleverness

If the best-practice approach differs significantly from our current implementation, explain what we currently have wrong and why the change matters. Do not apply quick patches to the existing code — propose the correct approach even if it requires more work.
```

### Pattern 5: Give Claude an "Out" (Permit "I Don't Know")

**Explanation:** Claude will attempt to answer every question, even when it should not. If you do not explicitly give it permission to say "I don't know" or "I'm not sure about this", it will hallucinate an answer rather than admit uncertainty. This is particularly dangerous for version-specific API details, library configurations, and platform-specific behaviour.

**When to use:** Any question about specific API versions, library compatibility, platform-specific behaviour, or configuration details that Claude might not have reliable training data for.

**Cross-track note:** This is valuable for General users too — especially when asking Claude about specific company policies, legal requirements, or factual claims. Note with Badge.

**Copyable prompt example:**

```
I need to configure Ghost Inspector to run against our staging environment with SSO authentication enabled.

Important: if you are not confident about specific Ghost Inspector configuration options or API details, say so explicitly rather than guessing. It is better to tell me "I'm not sure about this specific setting — check the Ghost Inspector docs" than to give me a configuration that might not work.

With that caveat, how would you approach this?
```

### Pattern 6: Outline Open Questions Before Implementing

**Explanation:** For larger tasks, ask Claude to identify all the open questions and unknowns first, then answer each one, and only then move to implementation. This three-step process (identify questions, answer questions, implement) prevents Claude from making silent assumptions that lead to hallucinated code paths.

**When to use:** Any task that spans multiple systems, involves unfamiliar APIs, requires integration work, or has ambiguous requirements.

**Copyable prompt example:**

```
I need to build an integration between our WordPress site's contact form and the existing .NET CRM system via a REST API.

Step 1 — Before suggesting any implementation:
List every open question or assumption you would need to resolve before building this. Consider: authentication, data mapping, error handling, rate limiting, existing API endpoints, WordPress hooks, and anything else relevant.

Do not answer the questions yet. Just list them so I can provide the answers or confirm your assumptions.
```

**Follow-up prompt (after answering the questions):**

```
Here are the answers to your open questions:

[paste answers]

Now, based on these confirmed details, outline the implementation approach. If any of my answers have created new questions, raise those before proceeding to code.
```

### Pattern 7: Validate Against Existing Code First

**Explanation:** Claude frequently hallucinates function signatures, import paths, and API patterns that look correct but do not match your actual codebase. Asking it to read and reference the existing code before making changes grounds its output in reality rather than its training data.

**When to use:** Any time you are modifying existing code, especially when working with custom frameworks, internal libraries, or non-standard project structures.

**Copyable prompt example:**

```
I need to add a new endpoint to our API for exporting safeguarding audit reports as PDFs.

Before writing any new code:
1. Read the existing controller files in /Controllers/ to understand our current patterns for API endpoints
2. Read the existing service layer in /Services/ to understand how we structure business logic
3. Check the existing PDF generation code (if any) in the codebase

Then propose the new endpoint following the exact same patterns, naming conventions, and project structure as the existing code. Cite the specific files and patterns you are following.
```

### The Agent Harness Concept

After the seven individual patterns, present the agent harness as a synthesising concept. This was discussed in the dev training session under "Development and Code Review Integration" as an "agent harness for structured optimisation."

**What it is:** A structured, multi-step workflow where you combine several of the above patterns into a deliberate sequence for complex development work. Rather than ad-hoc prompting, the harness defines a repeatable process.

**The harness workflow:**

1. **Scope** — Break the task into atomic subtasks (Pattern 1)
2. **Research** — For each subtask, ask Claude to identify open questions (Pattern 6)
3. **Resolve** — Answer the open questions, giving Claude explicit "outs" for uncertainty (Pattern 5)
4. **Plan** — Ask for options and a recommended approach (Patterns 2 + 3)
5. **Validate** — Have Claude check its plan against existing code and best practices (Patterns 4 + 7)
6. **Implement** — Only now does Claude write code, working from a validated plan
7. **Review** — Claude reviews its own output against the plan and flags any deviations

**Copyable harness kickoff prompt:**

```
I am going to use a structured workflow for this task. We will go through these steps in order — do not skip ahead:

1. SCOPE: I will describe the task. You break it into atomic subtasks.
2. RESEARCH: For each subtask, list open questions and assumptions.
3. RESOLVE: I will answer your questions. Flag anything you are uncertain about.
4. PLAN: Present 2-3 implementation options with trade-offs for the first subtask.
5. VALIDATE: Check your recommended option against our existing codebase patterns.
6. IMPLEMENT: Write the code for the first subtask only.
7. REVIEW: Review your own output against the plan. Flag any deviations.

We will then repeat steps 4-7 for each remaining subtask.

Here is the task: [describe task]

Start with step 1 — break this into atomic subtasks.
```

**Positioning:** Frame the agent harness as the "full version" of these patterns — for use on substantial development work (new features, major refactors, system integrations). The individual patterns are useful on their own for smaller tasks.

### Section Summary / Key Takeaways

End with a concise summary card that distils the core message:

- **Claude performs best with focused, well-scoped tasks.** Break big work into small pieces.
- **Always plan before implementing.** A 2-minute planning prompt saves hours of debugging hallucinated code.
- **Give Claude permission to say "I don't know."** Uncertainty is better than a confident hallucination.
- **Ask for options, not answers.** When Claude presents alternatives, it has to reason about trade-offs.
- **Ground Claude in your actual code.** Make it read existing patterns before writing new ones.
- **For complex work, use the agent harness.** Combine all the patterns into a structured sequence.

## Interaction Design

### Components Used

| Component | Source | Usage |
|-----------|--------|-------|
| `Card` | shadcn/ui | Each pattern is presented in a Card with a header (pattern name), explanation, and copyable prompt example. |
| `Accordion` | shadcn/ui | Patterns can be collapsed/expanded. Default: all expanded on first visit, with option to collapse for reference use. |
| `Badge` | shadcn/ui | "Also useful for General users" badges on patterns 1, 2, 5 (the cross-track ones). Variant: secondary/outline. |
| `Alert` | shadcn/ui | The agent harness section uses an Alert callout to distinguish it from the individual patterns. |
| `Button` | shadcn/ui | Copy-to-clipboard buttons on every prompt example. |
| `Collapsible` | shadcn/ui | The "follow-up prompt" in Pattern 6 is inside a Collapsible ("Show follow-up prompt"). |
| `Separator` | shadcn/ui | Between the individual patterns section and the agent harness section. |
| `Tooltip` | shadcn/ui | On the "Also useful for General users" badge, to explain what this means on hover/focus. |

### Layout

- **Mobile (< 640px):** Single column. Pattern cards stack vertically. Prompt code blocks scroll horizontally if needed. Copy buttons remain visible (positioned top-right of each code block).
- **Tablet (640px-1023px):** Single column with wider content area. Same card layout with more breathing room.
- **Desktop (1024px+):** Single column for content (max-width: 65ch for body text). Pattern cards extend to a slightly wider max-width to accommodate code blocks without excessive horizontal scrolling. The agent harness section has a distinct visual treatment (Alert background).

### Pattern Card Structure

Each pattern card follows this consistent structure:

1. **Pattern number and name** (heading, inside Card header)
2. **Badge** ("Also useful for General users") — if applicable, positioned beside the heading
3. **"When to use" line** — a single sentence in secondary text
4. **Explanation** — 2-3 short paragraphs
5. **Copyable prompt** — syntax-highlighted code block (Shiki, language: `text` or `markdown`) with copy button

### Animation / Motion

- **Pattern cards:** No entrance animation — content loads immediately. If the section is accessed via anchor link or navigation, scroll to the relevant pattern.
- **Accordion expand/collapse:** Use shadcn Accordion's built-in animation (Radix). Duration: 300-500ms, ease-out.
- **Collapsible (follow-up prompt):** Same animation profile as accordion.
- **Copy button feedback:** Icon transition (Copy to Check) — CSS transition only, 200ms.
- **All animations respect `prefers-reduced-motion`.**

### Navigation within the Section

- Consider a mini-nav/table of contents at the top of the section listing all seven patterns plus the agent harness. Each item links to its anchor. This is especially useful on mobile where the section is long.
- On desktop, if a sticky sidebar is available from the app shell, the pattern names should populate it.

## Copyable Content

This section is the most prompt-heavy in the entire playbook. Every prompt below must have a copy-to-clipboard button using the `useCopyToClipboard` hook and `CopyButton` component.

### Prompt 1: Atomic Task Breakdown
```
I need to migrate the safeguarding audit form from the legacy ASP.NET Web Forms page to a Razor Pages implementation.

Before writing any code, break this into a numbered list of atomic subtasks. Each subtask should:
- Change no more than 2-3 files
- Have a single clear objective
- Be independently testable

List the subtasks in dependency order. Do not implement anything yet.
```

### Prompt 2: Plan Before Implementing
```
I want to add role-based access control to the LMS admin dashboard. Before writing any code, create a plan that covers:

1. What changes are needed and where (list specific files)
2. Your recommended approach and why
3. Any assumptions you are making
4. What could go wrong or what edge cases should we handle
5. What you would need to verify before implementing

Do not write any code yet. Present the plan and wait for my feedback.
```

### Prompt 3: Options and Trade-offs
```
We need to implement automated email notifications for overdue safeguarding training in the LMS. Our stack is ASP.NET/C# with SQL Server.

Present 2-3 different approaches for the notification system. For each option, include:
- How it works (brief technical description)
- Pros and cons
- Estimated complexity (low / medium / high)
- Any dependencies or infrastructure requirements

Do not recommend one yet — just present the options so I can evaluate them.
```

### Prompt 4: Best Practice Enforcement
```
I need to update the user authentication flow in our ASP.NET application. Requirements:

- Follow current ASP.NET Core Identity best practices
- Must comply with OWASP authentication guidelines
- We hold ISO 27001 certification, so security patterns must be auditable
- Prioritise maintainability over cleverness

If the best-practice approach differs significantly from our current implementation, explain what we currently have wrong and why the change matters. Do not apply quick patches to the existing code — propose the correct approach even if it requires more work.
```

### Prompt 5: Explicit "I Don't Know" Permission
```
I need to configure Ghost Inspector to run against our staging environment with SSO authentication enabled.

Important: if you are not confident about specific Ghost Inspector configuration options or API details, say so explicitly rather than guessing. It is better to tell me "I'm not sure about this specific setting — check the Ghost Inspector docs" than to give me a configuration that might not work.

With that caveat, how would you approach this?
```

### Prompt 6a: Open Questions First
```
I need to build an integration between our WordPress site's contact form and the existing .NET CRM system via a REST API.

Step 1 — Before suggesting any implementation:
List every open question or assumption you would need to resolve before building this. Consider: authentication, data mapping, error handling, rate limiting, existing API endpoints, WordPress hooks, and anything else relevant.

Do not answer the questions yet. Just list them so I can provide the answers or confirm your assumptions.
```

### Prompt 6b: Follow-up (Resolving Questions)
```
Here are the answers to your open questions:

[paste answers]

Now, based on these confirmed details, outline the implementation approach. If any of my answers have created new questions, raise those before proceeding to code.
```

### Prompt 7: Validate Against Existing Code
```
I need to add a new endpoint to our API for exporting safeguarding audit reports as PDFs.

Before writing any new code:
1. Read the existing controller files in /Controllers/ to understand our current patterns for API endpoints
2. Read the existing service layer in /Services/ to understand how we structure business logic
3. Check the existing PDF generation code (if any) in the codebase

Then propose the new endpoint following the exact same patterns, naming conventions, and project structure as the existing code. Cite the specific files and patterns you are following.
```

### Prompt 8: Agent Harness Kickoff
```
I am going to use a structured workflow for this task. We will go through these steps in order — do not skip ahead:

1. SCOPE: I will describe the task. You break it into atomic subtasks.
2. RESEARCH: For each subtask, list open questions and assumptions.
3. RESOLVE: I will answer your questions. Flag anything you are uncertain about.
4. PLAN: Present 2-3 implementation options with trade-offs for the first subtask.
5. VALIDATE: Check your recommended option against our existing codebase patterns.
6. IMPLEMENT: Write the code for the first subtask only.
7. REVIEW: Review your own output against the plan. Flag any deviations.

We will then repeat steps 4-7 for each remaining subtask.

Here is the task: [describe task]

Start with step 1 — break this into atomic subtasks.
```

## Two-Track Considerations

This section sits in the **Developer track**, but several patterns have clear applicability to General users:

| Pattern | General Track Relevance | Treatment |
|---------|------------------------|-----------|
| 1. Atomic task breakdown | High — breaking documents, analysis, or projects into parts | Badge: "Also useful for General users" + brief note |
| 2. Plan before implementing | High — ask Claude to outline its approach before producing any output | Badge + brief note |
| 3. Options and trade-offs | Medium — useful for complex decisions but less common for general use | No badge; developer-focused |
| 4. Best practice | Low — mainly a coding concept | No badge |
| 5. Give an "out" | High — relevant whenever asking Claude factual questions | Badge + brief note |
| 6. Open questions first | Medium — useful for complex projects | No badge |
| 7. Validate against existing code | Low — developer-specific | No badge |
| Agent harness | Low — developer workflow concept | No badge |

**For patterns marked "Also useful for General users":** Include a brief sentence (not a full separate example) explaining how General users might apply the pattern. For example, Pattern 2 could note: "This works just as well outside of coding — ask Claude to outline its plan before writing a report, drafting a policy, or preparing meeting notes."

**Do not duplicate the full section in the General track.** The cross-track badges and brief notes are sufficient to signal relevance. General users who explore the Developer track will find the content accessible for these marked patterns.

## Acceptance Criteria

1. All seven anti-hallucination patterns are presented, each with: a clear name, a "when to use" indicator, a concise explanation, and a copyable prompt example.
2. Every copyable prompt uses Phew!-relevant context (WordPress, ASP.NET/C#, safeguarding, LMS, ISO certification) — not generic placeholder examples.
3. Each prompt has a functional copy-to-clipboard button using the shared `CopyButton` component.
4. Prompts are syntax-highlighted using Shiki (language: `text` or `markdown`).
5. Patterns 1, 2, and 5 display an "Also useful for General users" badge with a tooltip explaining cross-track relevance.
6. Pattern 6 includes both the initial prompt and a collapsible follow-up prompt.
7. The agent harness concept is presented as a distinct section (visually separated from the individual patterns) with its own copyable kickoff prompt.
8. A mini-nav or table of contents at the top lists all patterns and the agent harness, with anchor links.
9. A summary/key takeaways card appears at the end of the section.
10. All body text is at least 16px (1rem) with a maximum line length of 65ch.
11. Prompt code blocks have sufficient width and horizontal scrolling if needed on mobile.
12. The section is fully responsive: readable on mobile without horizontal scrolling of body text.
13. Keyboard navigation works: Tab moves between interactive elements (accordion triggers, copy buttons, collapsible triggers), focus indicators are visible.
14. All animations respect `prefers-reduced-motion`.
15. UK English is used throughout all copy.
16. Semantic HTML: proper heading hierarchy (h2 for section title, h3 for each pattern, h3 for agent harness), landmark elements.
17. No "AI slop" design patterns.
18. Content is defined as typed TypeScript objects (pattern name, explanation, whenToUse, prompt, crossTrack flag) — not hard-coded JSX.

## Build Agent Checklist

### Frontend Quality Checklist

**Typography**
- [ ] Body text >= 16px (1rem), using rem units
- [ ] Max line length: 65ch for body text
- [ ] Fluid type (clamp) on headings; fixed sizes on UI controls
- [ ] Font stacks include size-adjusted fallback
- [ ] No generic fonts (Inter, Roboto, etc.) unless explicitly specified

**Colour & Theming**
- [ ] All custom colours defined in OKLCH via CSS variables
- [ ] Neutrals tinted towards brand hue (not pure grey)
- [ ] No pure black (#000) or pure white (#fff)
- [ ] Dark mode tested and functional (if applicable to section)
- [ ] All text meets WCAG AA contrast (4.5:1 body, 3:1 large/UI)

**Layout & Spacing**
- [ ] Spacing values from the 4pt grid (4, 8, 12, 16, 24, 32, 48, 64, 96)
- [ ] Visual hierarchy uses 2+ dimensions (size, weight, colour, space)
- [ ] No nested cards
- [ ] No identical repeating card grids

**Motion & Animation**
- [ ] Only `transform` and `opacity` animated (no width/height/top/left)
- [ ] Timing follows 100/300/500 rule
- [ ] Easing uses exponential curves (not default `ease` or bounce)
- [ ] `prefers-reduced-motion` handled (crossfade fallback or disable)
- [ ] Exit animations faster than entrances
- [ ] Motion used via Tailwind transitions where CSS suffices; Motion library only for layout/enter/exit

**Interaction**
- [ ] All 8 interactive states designed (default, hover, focus, active, disabled, loading, error, success)
- [ ] `:focus-visible` ring on all interactive elements (2-3px, offset, 3:1 contrast)
- [ ] Touch targets >= 44px
- [ ] Copy-to-clipboard on every prompt/template/code block
- [ ] Skeleton screens for loading states (not generic spinners)

**Accessibility**
- [ ] Semantic HTML (headings, landmarks, labels)
- [ ] Skip link present
- [ ] Keyboard navigation tested (Tab, Enter, Escape, Arrows)
- [ ] `aria-expanded`, `aria-controls` on accordions/collapsibles
- [ ] `aria-label` on icon-only buttons
- [ ] Images have `alt` text (or `alt=""` for decorative)
- [ ] Never `outline: none` without `:focus-visible` replacement

**Performance**
- [ ] No barrel file imports (direct imports from source)
- [ ] Shiki lazy-loaded (not in initial bundle)
- [ ] Derived state computed during render (no useEffect for derived values)
- [ ] `content-visibility: auto` on long scrollable content
- [ ] Passive event listeners on scroll/touch handlers
- [ ] Static JSX hoisted outside components where possible

**Responsive**
- [ ] Mobile-first (base styles for mobile, min-width queries for larger)
- [ ] Tested at 320px, 640px, 768px, 1024px widths
- [ ] No critical functionality hidden on mobile
- [ ] Hover-dependent features have touch alternatives
- [ ] Safe area insets handled for mobile

**UX Writing & Content**
- [ ] UK English throughout (spelling, grammar, currency, date format)
- [ ] Button labels use verb + object pattern
- [ ] Error messages answer: what, why, how to fix
- [ ] Consistent terminology (no synonyms for the same action)
- [ ] Empty states are actionable, not just "Nothing here"

**Code Quality**
- [ ] Tailwind utility classes only (no CSS modules or styled-components)
- [ ] `cn()` utility for conditional class merging
- [ ] `@/` path alias for all imports
- [ ] Components composed from shadcn primitives (not mega-components)
- [ ] Content defined as typed TS objects, not hard-coded JSX
