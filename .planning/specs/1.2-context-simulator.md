# Spec 1.2 — How Context Works (Interactive Simulator)

> **Phase 2 build agent:** Agent 2 — Context & Session Management
> **Track:** Both (General + Developer)
> **Route:** `/:track/how-context-works`
> **Component location:** `src/components/interactive/ContextWindowSimulator.tsx`

---

## Purpose

This is the **hero piece** of the entire playbook — the single most complex and valuable interactive component. It teaches Phew! staff (both general users and developers) how Claude's context window works, why it matters, and what to do about it.

The section achieves three goals:
1. **Demystify context** — make an invisible, abstract concept tangible through proportional visualisation
2. **Build intuition for session management** — users should leave understanding *why* fresh sessions matter, not just that they should start them
3. **Provide actionable tools** — a copyable session handoff prompt they can use immediately

The visualisation must feel like a genuine teaching tool, not a decorative chart. Every interactive element exists to reinforce a concept.

---

## Source References

The build agent MUST read these files before starting work:

| File | What to extract |
|---|---|
| `.planning/research/context-window-mechanics.md` | **Primary content source.** All token ranges, segment breakdowns, degradation stages, compaction mechanics, and practical tips. Sections 1-9. |
| `.planning/research/app-tech-stack.md` | Section 2 (Context Window Simulator implementation pattern), Section 7 (Motion animation), Architectural Conventions |
| `.planning/research/frontend-skills-review.md` | Full design guidelines and the Build Agent Checklist (Section 10 at the end) |
| `.planning/research/remotion-evaluation.md` | Confirms approach: custom div + Tailwind + Motion. Do NOT use Remotion, D3, or Recharts. |
| `.planning/source-context/claude-code-capabilities-extension-options.md` | Official "Context cost by feature" table — use for the Developer track's technical detail panel |

---

## Content Outline

This section has four content areas, presented in order: an introduction, the interactive simulator, an educational narrative, and a copyable handoff prompt. The build agent must implement all four.

### Area 1: Introduction (above the simulator)

**Heading:** "How Context Works"

**Lead text (both tracks):**

> Every conversation with Claude happens inside a context window — 200,000 tokens of working memory. Think of it as a desk: the more you pile on, the harder it is to find what you need. Understanding what's already on your desk when you start, and how it fills up as you work, is the single most useful thing you can learn about using Claude effectively.

**Key concept box** (styled as a subtle callout, not a card-inside-card):

> **What is a token?** Roughly 0.75 words. 200,000 tokens is about 150,000 words — the length of two full novels. That sounds like a lot, but a surprising amount is used before you type your first message.

**Developer track addition** (shown only on `:track === 'developer'`):

> **Technical note:** Claude's standard context window is 200,000 tokens. An extended 1M-token window is available via the API (beta, usage tier 4, requires header `context-1m-2025-08-07`), charged at premium rates (2x input, 1.5x output). Claude Code uses the 200K window by default.

---

### Area 2: The Interactive Simulator

This is the core visual component. See the **Interaction Design** section below for full implementation details. The simulator comprises:

1. **A proportional stacked bar** showing how the 200K window is allocated
2. **Interactive controls** that let users adjust configuration and add messages
3. **A degradation overlay** that visualises attention fade as context fills
4. **Status indicators** showing current usage, available space, and degradation stage

#### Segment Data (200K window baseline)

These are the segments to display in the proportional bar. All values are **ballpark estimates** — the UI must include a visible caveat.

| Segment | Default Tokens | Percentage | Colour Role | Notes |
|---|---|---|---|---|
| **System Prompt** | 5,000 | 2.5% | Indigo/deep blue | Claude's core instructions. Always present. |
| **Built-in Tools** | 15,000 | 7.5% | Blue | JSON schemas for Read, Write, Edit, Bash, Glob, Grep, etc. (~15-18 tools) |
| **CLAUDE.md** | 4,000 | 2.0% | Teal/cyan | Project conventions. Size depends on content (~20 tokens/line). |
| **MCP Tools** | 12,000 | 6.0% | Amber/orange | External tool definitions. Highly variable (0-60,000+). |
| **Skills** | 1,000 | 0.5% | Purple | Brief skill descriptions. Zero if `disable-model-invocation: true`. |
| **Environment** | 1,000 | 0.5% | Slate/grey | Git status, working directory, OS info. |
| **Conversation** | 122,000 | 61.0% | Green (graduated) | User messages + Claude responses. This is what grows. |
| **Response Buffer** | 40,000 | 20.0% | Muted/hatched | Reserved for Claude's next response. NOT available for conversation. |

**Total fixed overhead (default):** ~38,000 tokens (19.0%)
**Available for conversation:** ~122,000 tokens (61.0%)
**Response buffer reserve:** ~40,000 tokens (20.0%)

#### Caveat Text (always visible near the simulator)

> **Note:** These numbers are ballpark estimates. Exact token counts vary by Claude version, model, configuration, and content. The proportions are more important than the precise figures — they show how much of your context is spoken for before you begin.

#### Preset Configurations

Provide three quick-select presets that reconfigure all sliders at once:

| Preset | MCP Servers | CLAUDE.md Lines | Skills | Tool Search |
|---|---|---|---|---|
| **Minimal** (new project, no extras) | 0 | 50 | 0 | Yes |
| **Moderate** (typical Phew! setup) | 2 | 200 | 3 | Yes |
| **Heavy** (many integrations) | 5 | 500 | 10 | No |

Display the resulting available conversation space prominently for each:
- Minimal: ~149,000 tokens available (~74.5%)
- Moderate: ~122,000 tokens available (~61.0%)
- Heavy: ~55,000-102,000 tokens available (~27.5-51.0%)

#### Slider-Adjustable Parameters

| Parameter | Default | Range | Step | Token Calculation | Visible on Track |
|---|---|---|---|---|---|
| MCP servers | 2 | 0–10 | 1 | Each adds ~6,000 tokens (midpoint of 4,000-8,000 range) | Both |
| CLAUDE.md size (lines) | 200 | 0–1,000 | 50 | ~20 tokens/line | Both |
| Number of skills | 3 | 0–20 | 1 | ~400 tokens per skill (midpoint of 300-500 range) | Developer only |
| Tool Search enabled | Yes | Yes/No | toggle | If No, MCP overhead multiplied by ~3x | Developer only |

When Tool Search is enabled, MCP tokens are capped at 10% of context (~20,000 tokens maximum), regardless of how many servers are configured. When disabled, full MCP tool schemas load (~6,000 tokens per server).

#### "Add Message" Interaction

A button labelled **"Add a conversation turn"** (or similar). Each press simulates a user message + Claude response pair:

- Each turn adds approximately **3,000-8,000 tokens** to the conversation segment (randomised within this range, or the user can choose a preset: "Short exchange" ~3,000, "Code review" ~6,000, "File reading + edit" ~8,000).
- The conversation segment grows visually with each press.
- The fixed overhead segments and response buffer do NOT change — only the conversation segment fills.
- A running counter displays: "Turn X — Y tokens used (Z% of window)"

**Developer track addition:** Show a breakdown per turn: "~1,200 tokens (your message) + ~4,800 tokens (Claude's response including tool calls)" with a note that tool results (file reads, command output) are the biggest consumers.

#### Degradation Stages (overlay on conversation segment)

As the conversation segment fills, apply a visual overlay that represents the U-shaped attention curve ("lost in the middle" effect). The overlay intensifies through four stages:

| Stage | Context Usage | Visual Treatment | Label | Description |
|---|---|---|---|---|
| **Healthy** | 0–50% | No overlay. All segments at full opacity. | "Full attention" | Claude can recall everything in the conversation accurately. |
| **Early degradation** | 50–70% | Subtle gradient: middle of conversation segment at ~85% opacity. Top/bottom remain full. | "Slight fade" | Instructions from the middle of your conversation start getting less weight. You might need to repeat things. |
| **Noticeable degradation** | 70–85% | Pronounced gradient: middle at ~60% opacity. Clear U-shape visible. Top and bottom remain strong. | "Noticeable fade" | Claude may re-read files it already examined, ask about things previously discussed, or contradict earlier decisions. Responses get slower. |
| **Critical** | 85–95% | Strong gradient: middle at ~35% opacity. Only the most recent messages and system prompt are clearly visible. Compaction warning pulses. | "Critical — consider a fresh session" | Quality has significantly degraded. Earlier context is largely ineffective. Auto-compaction may trigger. |

**Visual implementation of the U-shape:**

The conversation segment should show an attention gradient that reflects the academic research:
- **Bottom of the bar** (earliest messages): Moderate attention (primacy bias, but fading)
- **Middle of the bar**: Weakest attention (lost in the middle)
- **Top of the bar** (most recent messages): Strongest attention (recency bias)
- **System prompt/CLAUDE.md** (separate segments, always at the start of context): Strong attention (primacy bias, structural position)

The gradient should be implemented as an opacity overlay on the conversation segment, NOT by changing the segment's base colour. Use a CSS gradient that creates the U-shape pattern.

#### Compaction Animation

When context reaches 90%+, show a **"Compaction"** button (or auto-trigger with a brief delay). The compaction animation should:

1. Flash a brief message: "Compacting conversation..."
2. The conversation segment **shrinks to approximately 50%** of its current size (representing the summary replacing verbose history)
3. The freed space appears as available conversation room again
4. A small "Compacted" badge appears on the conversation segment
5. A tooltip on the badge explains: "Claude has summarised your conversation history. Key decisions and progress are preserved, but specific details and nuance from earlier exchanges may be lost."

**Post-compaction state:** The conversation segment is smaller, but the degradation overlay resets (the summary is fresh context, so attention is uniform again). If the user continues adding turns, degradation begins anew — and a note explains that a second compaction loses even more detail.

---

### Area 3: Educational Narrative (below the simulator)

This content sits below the interactive component and explains what the user just experienced. It should be structured as a series of collapsible sections (shadcn Accordion) so users can read what interests them without being overwhelmed.

#### 3a. "Why Does This Matter?" (expanded by default)

**Both tracks:**

> When your context window fills up, Claude does not suddenly "forget" things — but it becomes progressively less effective at using information from the middle of your conversation. This is a well-documented property of how large language models process text (researchers call it "lost in the middle"). The most recent things you said and the instructions loaded at the start (your CLAUDE.md, system prompt) stay strong. Everything in between gradually fades.

> **The practical result:** Claude might re-read files it already looked at, ask you questions you already answered, ignore conventions you established earlier, or try random solutions instead of reasoning through the problem.

#### 3b. "Signs Your Context is Getting Full" (collapsed by default)

Present as a numbered list:

1. Claude asks about something you already told it
2. Claude re-reads files it recently read
3. Claude ignores conventions established earlier in the session
4. Responses become noticeably slower
5. Claude tries random approaches instead of reasoning through the problem
6. The "compacting conversation" message appears (in Claude Code)
7. `/cost` shows high context usage percentage (in Claude Code)

**General track:** Present items 1-5 only (items 6-7 are Claude Code specific).
**Developer track:** Present all seven items.

#### 3c. "What Gets Lost in Compaction" (collapsed by default)

**Both tracks:**

> When the context window is nearly full, Claude automatically summarises (compacts) your conversation to free up space. This preserves the gist but loses detail.

**What is preserved (summarised):**
- Key decisions and their rationale
- Current task state and progress
- Important code snippets and patterns
- Next steps identified

**What is lost (dropped):**
- Verbose file contents from earlier reads
- Error traces from resolved issues
- Trial-and-error iteration history
- Nuanced instructions given early in the conversation
- Specific phrasing and tone preferences
- Detailed tool results from earlier operations

**Developer track addition:**

> **How compaction works under the hood:** When input tokens exceed ~80-95% of the window, Claude generates a summary of the entire conversation. This summary replaces all previous conversation history. The system prompt, tool definitions, CLAUDE.md, and environment context are reloaded fresh (not summarised). The compaction typically frees ~50% of consumed context tokens.

> **Manual compaction:** In Claude Code, run `/compact` at any time. You can provide focus instructions:
> - `/compact` — general summarisation
> - `/compact only keep the API patterns we established` — focused preservation
> - `/compact preserve the coding patterns and file structure` — targeted retention

#### 3d. "How to Get the Most from Your Context" (collapsed by default)

**Both tracks — present as practical tips:**

1. **Start fresh for each task.** One context window per task. If the task is done, start a new session for the next one.
2. **Don't wait for degradation.** Start a fresh session when you're around 60-70% full — don't push through until quality drops.
3. **Put critical instructions in CLAUDE.md.** These load at the start of every session and benefit from primacy bias (the model pays strong attention to what comes first).
4. **Repeat important context in your latest message.** The model pays strong attention to the most recent input (recency bias).
5. **Don't rely on mid-conversation instructions.** If you said "always use TypeScript" ten messages ago, it may have faded. Put it in CLAUDE.md instead.

**Developer track additions:**

6. **Keep CLAUDE.md under ~500 lines.** Move reference material to skills (which load on-demand, not at startup).
7. **Disconnect unused MCP servers.** Run `/mcp` to see token costs per server.
8. **Use Tool Search** (enabled by default since v2.1.7+) to defer MCP tool loading.
9. **Set `disable-model-invocation: true`** on skills you only trigger manually — their descriptions won't consume context.
10. **Use subagents for file-heavy tasks** — their context is isolated from yours, so only the summary returns.
11. **Run `/compact` proactively** at ~60-70% rather than waiting for auto-compact. Provide focus instructions to preserve what matters.
12. **Monitor usage with `/cost`** throughout a session.

#### 3e. "The Response Buffer — The Hidden Reserve" (collapsed by default, Developer track only)

> Claude Code reserves approximately 33,000-45,000 tokens (roughly 20% of the window) as a buffer for generating responses. This space is NOT available for your conversation history.

> **Key insight:** The "context remaining" percentage shown in Claude Code's status bar includes this buffer. When it shows 20% remaining, you may only have ~3.5% of true free space before compaction triggers. This is why degradation sometimes seems to happen "suddenly" — the available space was smaller than the percentage suggested.

---

### Area 4: Session Handoff Prompt (below the narrative)

This is a copyable prompt with a copy-to-clipboard button. It must be prominently positioned with a clear heading.

**Heading:** "Session Handoff Prompt — Start Fresh Without Losing Progress"

**Introductory text:**

> When your session is getting long, use this prompt to ask Claude to write its own summary. Copy the output, start a fresh session, and paste it as your opening message. You get a clean context window with all the important context carried forward.

See the **Copyable Content** section below for the exact prompt text.

---

## Interaction Design

### Component Architecture

```
ContextWindowSection/
├── ContextWindowSection.tsx          # Page-level container, manages track
├── SimulatorIntro.tsx                # Area 1: heading, lead text, concept box
├── ContextWindowSimulator/
│   ├── ContextWindowSimulator.tsx    # Main simulator orchestrator (state, calculations)
│   ├── ContextBar.tsx               # The proportional stacked bar
│   ├── ContextSegment.tsx           # Individual segment within the bar
│   ├── DegradationOverlay.tsx       # U-shaped attention gradient
│   ├── CompactionAnimation.tsx      # Compaction sequence
│   ├── SimulatorControls.tsx        # Sliders, presets, add-message button
│   ├── SimulatorStatus.tsx          # Usage counter, degradation stage label
│   └── SegmentTooltip.tsx           # Tooltip content for each segment
├── EducationalNarrative.tsx          # Area 3: accordion sections
├── SessionHandoffPrompt.tsx          # Area 4: copyable prompt block
└── context-simulator-data.ts         # Typed data: segments, presets, degradation thresholds
```

### State Management

All state is local to `ContextWindowSimulator.tsx`. No global state, no context providers. State shape:

```typescript
interface SimulatorState {
  // Configuration (from sliders/presets)
  mpcServers: number;           // 0-10, default 2
  claudeMdLines: number;        // 0-1000, default 200
  skillCount: number;           // 0-20, default 3
  toolSearchEnabled: boolean;   // default true

  // Conversation state
  conversationTurns: ConversationTurn[];  // Array of added turns
  isCompacted: boolean;         // Whether compaction has occurred
  compactionCount: number;      // How many times compacted

  // UI state
  activePreset: 'minimal' | 'moderate' | 'heavy' | null;
}

interface ConversationTurn {
  id: string;
  tokens: number;       // Randomised within range
  label: string;        // "Turn 1", "Turn 2", etc.
}
```

**Derived values** (computed during render, NOT stored in state):

```typescript
// Fixed overhead calculation
const systemPromptTokens = 5000;  // Constant
const builtInToolTokens = 15000;  // Constant
const claudeMdTokens = state.claudeMdLines * 20;
const mpcTokens = state.toolSearchEnabled
  ? Math.min(state.mpcServers * 6000, 20000)  // Capped at 10% of 200K
  : state.mpcServers * 6000;
const skillTokens = state.skillCount * 400;
const environmentTokens = 1000;  // Constant
const responseBuffer = 40000;    // Constant

const fixedOverhead = systemPromptTokens + builtInToolTokens + claudeMdTokens
  + mpcTokens + skillTokens + environmentTokens;
const conversationTokens = state.conversationTurns.reduce((sum, t) => sum + t.tokens, 0);
const compactedConversationTokens = state.isCompacted
  ? Math.round(conversationTokens * 0.5)
  : conversationTokens;
const totalUsed = fixedOverhead + compactedConversationTokens + responseBuffer;
const availableForConversation = 200000 - fixedOverhead - responseBuffer;
const usagePercentage = ((fixedOverhead + compactedConversationTokens) / (200000 - responseBuffer)) * 100;

// Degradation stage
const degradationStage: 'healthy' | 'early' | 'noticeable' | 'critical' =
  usagePercentage < 50 ? 'healthy' :
  usagePercentage < 70 ? 'early' :
  usagePercentage < 85 ? 'noticeable' : 'critical';
```

### The Proportional Bar — ContextBar.tsx

**Layout:** A horizontal stacked bar, full width of the content area. Height: 48px on desktop, 40px on mobile. Rounded corners (border-radius from the 4pt grid: 8px).

**Segment rendering:**

Each segment is a `motion.div` with:
- `layout` prop for automatic width animation
- Width calculated as `(segment.tokens / 200000) * 100%`
- `style={{ width: ... }}` for dynamic values (this is the one exception to "no inline styles")
- Background colour from the segment's assigned colour role (see segment data table)
- Text label shown if the segment is wide enough (> 5% of total); otherwise, label is tooltip-only
- `aria-label` with full segment name and token count

**Minimum visual width:** Segments smaller than 1% of the bar should be rendered at a minimum visual width of 1% (with the tooltip showing the actual percentage). This prevents sub-pixel segments from being invisible.

**Segment order** (left to right, matching how context is actually structured):
1. System Prompt
2. Built-in Tools
3. CLAUDE.md
4. MCP Tools
5. Skills
6. Environment
7. Conversation (grows)
8. Available Space (shrinks)
9. Response Buffer

Note: "Available Space" is not a true segment — it is the unfilled portion of the bar between the conversation segment and the response buffer. It should be styled as empty/unfilled (use a subtle background pattern or very light colour to distinguish from the bar background).

### Degradation Overlay — DegradationOverlay.tsx

This is an absolutely-positioned div that sits over the **conversation segment only**. It renders a CSS gradient that creates the U-shaped attention pattern.

**Implementation approach:**

```tsx
// Pseudo-code for the gradient overlay
const overlayOpacity = {
  healthy: 0,       // No overlay
  early: 0.15,      // Subtle
  noticeable: 0.35, // Pronounced
  critical: 0.55,   // Strong
};

// The gradient creates the U-shape:
// - Top (recent messages) = transparent (strong attention)
// - Middle = opaque (weak attention)
// - Bottom (early messages) = semi-transparent (moderate attention, primacy fading)
const gradientStyle = {
  background: `linear-gradient(
    to bottom,
    transparent 0%,
    transparent 15%,
    rgba(0,0,0,${overlayOpacity[stage]}) 35%,
    rgba(0,0,0,${overlayOpacity[stage] * 1.2}) 50%,
    rgba(0,0,0,${overlayOpacity[stage]}) 65%,
    transparent 85%,
    transparent 100%
  )`,
};
```

**Important:** The overlay sits over the conversation segment, which is rendered **horizontally** in the bar. Since the bar is horizontal, "top" in the gradient corresponds to the **left edge** (early messages) and "bottom" corresponds to the **right edge** (recent messages). Adjust the gradient direction to `to right` (early = left, recent = right):

```
linear-gradient(
  to right,
  transparent 0%,                          /* System prompt side — strong (primacy) */
  rgba(0,0,0,opacity) 25%,                 /* Early conversation — fading */
  rgba(0,0,0,opacity * 1.2) 50%,           /* Middle — weakest attention */
  rgba(0,0,0,opacity) 75%,                 /* Later conversation — recovering */
  transparent 100%                          /* Most recent — strong (recency) */
)
```

The overlay uses `pointer-events: none` so tooltips and interactions on the segment beneath still work.

### Compaction Animation — CompactionAnimation.tsx

When triggered (button press or auto at 90%+):

1. **Phase 1 (300ms):** A pulsing overlay appears on the conversation segment with text "Compacting..." using `AnimatePresence` for enter.
2. **Phase 2 (500ms):** The conversation segment smoothly shrinks to 50% of its current width. Use Motion's `layout` animation — the width change flows naturally because it is derived from state, and `layout` animates the transition.
3. **Phase 3 (200ms):** The "Compacting..." overlay fades out. A small badge ("Compacted") appears at the left edge of the conversation segment.
4. **Phase 4:** Available space expands to fill the freed room. Degradation overlay resets to "healthy" (since the compacted summary is fresh context).

**State change:** Set `isCompacted: true`, `compactionCount: prev + 1`. The conversation token total is halved in the derived calculation.

**Reduced motion:** Under `prefers-reduced-motion`, skip the animation phases. Immediately update state and show the result. The "Compacted" badge still appears.

### Simulator Controls — SimulatorControls.tsx

**Layout:** Below the bar on desktop; collapsible panel on mobile (use shadcn Collapsible).

**Preset selector:** Three buttons in a row: "Minimal", "Moderate", "Heavy". Clicking one sets all sliders to the preset values. The active preset is visually highlighted. If the user manually adjusts any slider after selecting a preset, the active preset deselects (set to `null`).

**Sliders:**

Use native `<input type="range">` styled with Tailwind (or a shadcn Slider if available). Each slider shows:
- Label (left-aligned): "MCP Servers"
- Current value (right-aligned): "2 (~12,000 tokens)"
- The token impact updates in real-time as the slider moves

**Track-conditional controls:**
- Skills slider: visible on Developer track only
- Tool Search toggle: visible on Developer track only
- On General track, these use their defaults silently

**"Add a conversation turn" button:**

Primary action button. Positioned prominently below the sliders. On the Developer track, show a dropdown or set of sub-options:
- "Short exchange (~3,000 tokens)"
- "Code review (~6,000 tokens)"
- "File reading + edit (~8,000 tokens)"

On the General track, use a single button that adds a randomised turn (3,000-8,000 tokens).

**"Reset" button:** Small secondary/ghost button that resets conversation turns to empty, compaction state to false, and restores the active preset (or defaults if no preset was active).

**"Trigger compaction" button:** Appears only when usage exceeds 85%. Ghost/outline style. Developer track only. On the General track, compaction triggers automatically at 90%+ with an explanatory animation.

### Simulator Status — SimulatorStatus.tsx

A status bar displayed directly above or below the proportional bar. Shows:

- **Conversation turns:** "Turn 5 of ~18 before compaction" (estimate based on average turn size and remaining space)
- **Token usage:** "87,000 / 160,000 conversation tokens used (54%)"
- **Degradation stage:** Coloured badge — green "Healthy", amber "Early degradation", orange "Noticeable degradation", red "Critical"
- **Available space:** "73,000 tokens remaining for conversation"

The status bar updates in real-time as controls change or turns are added. Use `motion.span` with `layout` for smooth number transitions (optional, only if it does not feel over-animated — prefer restraint).

### Segment Tooltip — SegmentTooltip.tsx

Use shadcn `Tooltip` on each segment. Tooltip content:

```
System Prompt
~5,000 tokens (2.5%)

Claude's core instructions — personality, behaviour rules,
safety guidelines. Present in every request.
```

Each segment has a brief description (1-2 sentences) explaining what it is and why it matters. These descriptions come from the segment data table above.

**Touch support:** On touch devices, use tap-to-show (not hover) for tooltips. Ensure tooltips dismiss on tap-outside.

### Responsive Behaviour

**Desktop (>= 768px):**
- Proportional bar at full content width
- Controls displayed as a horizontal row below the bar
- Status bar above or below the bar
- Tooltips on hover

**Tablet (640-768px):**
- Bar at full width
- Controls stacked vertically
- Status bar stacked

**Mobile (< 640px):**
- Bar at full width, slightly taller (48px) for better touch targets
- Controls in a collapsible panel (collapsed by default, "Adjust settings" toggle)
- "Add turn" button always visible outside the collapsed panel
- Status bar simplified: just the percentage and degradation stage badge
- Tooltips on tap
- Segment labels hidden (tooltip-only) — bar shows colours only, with a legend below

**Mobile legend:** When segment labels are hidden, show a colour-coded legend below the bar:
```
[colour swatch] System Prompt  [colour swatch] Built-in Tools  [colour swatch] CLAUDE.md
[colour swatch] MCP Tools      [colour swatch] Skills          [colour swatch] Environment
[colour swatch] Conversation   [colour swatch] Response Buffer
```

### Animation Specifications

All animations use Motion (`motion/react`). Follow the timing/easing rules from the frontend skills review.

| Animation | Duration | Easing | Trigger | Reduced Motion Fallback |
|---|---|---|---|---|
| Segment width change (sliders) | 300ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | Slider value change | Instant update, no animation |
| Segment width change (add turn) | 300ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | Button press | Instant update |
| Degradation overlay transition | 500ms | `cubic-bezier(0.65, 0, 0.35, 1)` (ease-in-out) | Threshold crossed | Instant opacity change |
| Compaction shrink | 500ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | Compaction triggered | Instant resize |
| Compaction overlay enter | 300ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | Compaction triggered | No overlay, instant state change |
| Compaction overlay exit | 200ms | `cubic-bezier(0.7, 0, 0.84, 0)` (ease-in) | After shrink completes | No overlay |
| Preset button highlight | 150ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | Preset clicked | Instant |
| Status number change | 200ms | CSS transition (not Motion) | Value change | Instant |
| Badge enter (compacted) | 300ms | `cubic-bezier(0.16, 1, 0.3, 1)` (ease-out) | After compaction | Instant appear |

**Key rule:** Use Motion's `layout` prop for all segment width animations. This automatically handles the complex case where multiple segments resize simultaneously (e.g., changing MCP servers affects MCP segment width AND available space simultaneously). Do NOT manually animate widths with `animate={{ width: ... }}` — `layout` handles this more reliably.

**Reduced motion:** Wrap all animated components in a check:

```tsx
import { useReducedMotion } from 'motion/react';

function ContextSegment({ ... }) {
  const shouldReduceMotion = useReducedMotion();

  return (
    <motion.div
      layout={!shouldReduceMotion}
      transition={shouldReduceMotion ? { duration: 0 } : { duration: 0.3, ease: [0.16, 1, 0.3, 1] }}
      // ...
    />
  );
}
```

---

## Copyable Content

### Session Handoff Prompt

This prompt must be presented in a prominent code block with a copy-to-clipboard button. Use the `CodeBlock` + `CopyButton` pattern from the app-tech-stack research.

```
I need to wrap up this session and continue in a fresh one. Before we stop, please write a comprehensive handoff summary that I can paste into a new session. Include:

1. **What we were working on** — the overall goal and current task
2. **What we accomplished** — key decisions made, files created or modified, patterns established
3. **Current state** — what is working, what is partially complete, what is not started
4. **Important context** — any conventions, constraints, or requirements that a fresh session needs to know
5. **Next steps** — what should be done next, in priority order
6. **Open questions** — anything unresolved that needs attention

Format this as a single message I can paste at the start of a new session. Write it as instructions to your future self — assume the new session has no memory of this conversation.
```

**Introductory note above the prompt:**

> **How to use this:** Copy this prompt and send it to Claude when your session is getting long (around 60-70% context usage, or when you notice signs of degradation). Claude will write a detailed summary. Copy that summary, start a fresh session, and paste it as your first message. You get a clean 200,000-token window with all the important context carried forward.

**Post-prompt tip:**

> **Tip:** You can customise this prompt. If you are working on code, add "include the exact file paths and function names." If you are writing content, add "include the tone and style decisions we made." The more specific you are about what to preserve, the better the handoff.

### Developer Track Addition: Compact Instructions for CLAUDE.md

```
## Compact Instructions

When compacting this conversation, always preserve:
- Current task goals and acceptance criteria
- File paths and function signatures for in-progress work
- Architecture decisions and their rationale
- Testing patterns and conventions established
- Any known issues or edge cases identified
```

**Introductory note:**

> **For Claude Code users:** Add this section to your project CLAUDE.md to control what gets preserved during automatic compaction. Claude will reference these instructions when summarising your conversation.

---

## Two-Track Considerations

### General Track

The general track user is someone using Claude via claude.ai or Claude Desktop. They do not have Claude Code. They need to understand *why* context matters and *what to do about it*, but not the technical specifics.

**What to show:**
- All of Area 1 (introduction) except the developer technical note
- The full simulator, but with simplified controls (no Skills slider, no Tool Search toggle)
- Degradation stages 1-4 with practical descriptions
- Signs of degradation: items 1-5 only (no Claude Code-specific signs)
- All of "How to Get the Most from Your Context" tips 1-5
- The session handoff prompt (labelled for use in any Claude interface)

**What to hide:**
- Extended context (1M) technical note
- Skills slider and Tool Search toggle
- Compaction trigger button (auto-trigger only)
- "Signs" items 6-7 (Claude Code specific)
- Tips 6-12 (developer/Claude Code specific)
- "The Response Buffer" section (Area 3e)
- "How compaction works under the hood" technical detail
- Manual compaction commands
- CLAUDE.md compact instructions

**Tone adjustments:**
- Use "conversation" not "context window" where possible
- Say "Claude's working memory" not "200K token context"
- Focus on practical outcomes ("Claude starts forgetting things") not technical causes ("attention degradation in transformer architecture")

### Developer Track

The developer track user has Claude Code access (likely via IDE). They want the technical depth.

**What to show:** Everything. All controls, all technical notes, all tips, the response buffer section, compaction mechanics, CLAUDE.md compact instructions.

**What to add beyond general track:**
- Token breakdowns per conversation turn
- Conversation turn type selector (short exchange / code review / file reading)
- Response buffer explanation (Area 3e)
- Manual compaction commands and focus instructions
- CLAUDE.md compact instructions block
- References to `/cost`, `/mcp`, `/compact` commands
- Tool Search explanation and its impact on MCP overhead
- Technical note on extended thinking (thinking tokens consumed during turn but stripped after, so they do NOT permanently eat context)

**Tone adjustments:**
- Can use technical terminology freely (tokens, context window, compaction, primacy/recency bias)
- Reference specific Claude Code commands
- Include "under the hood" explanations where useful

### Implementation Pattern

Use the `useTrack()` hook (or URL param) to conditionally render content:

```tsx
import { useParams } from 'react-router';

function ContextWindowSection() {
  const { track } = useParams<{ track: 'general' | 'developer' }>();
  const isDev = track === 'developer';

  return (
    <>
      <SimulatorIntro isDev={isDev} />
      <ContextWindowSimulator isDev={isDev} />
      <EducationalNarrative isDev={isDev} />
      <SessionHandoffPrompt isDev={isDev} />
    </>
  );
}
```

Pass `isDev` as a prop to child components. Inside each component, use conditional rendering (`{isDev && <DevOnlyContent />}`) rather than separate component trees. This keeps the codebase maintainable — one component, two presentations.

---

## Content Data Structure

All content text should be defined as typed TypeScript objects in `context-simulator-data.ts`, not hard-coded into JSX. This enables future content updates without modifying component code.

```typescript
// src/content/shared/context-simulator-data.ts

export interface ContextSegmentData {
  id: string;
  label: string;
  defaultTokens: number;
  colour: string;              // Tailwind colour class
  description: string;         // For tooltip
  detailedDescription: string; // For developer track tooltip
  isFixed: boolean;            // Whether this segment changes with sliders
  isConversation: boolean;     // Whether this is the growing conversation segment
  isBuffer: boolean;           // Whether this is the response buffer
}

export interface PresetData {
  id: 'minimal' | 'moderate' | 'heavy';
  label: string;
  description: string;
  mpcServers: number;
  claudeMdLines: number;
  skillCount: number;
  toolSearchEnabled: boolean;
}

export interface DegradationStage {
  id: 'healthy' | 'early' | 'noticeable' | 'critical';
  label: string;
  threshold: number;           // Percentage at which this stage begins
  colour: string;              // Badge colour
  description: string;         // General track description
  detailedDescription: string; // Developer track description
  overlayOpacity: number;      // Opacity for degradation gradient
}

export interface ConversationTurnType {
  id: string;
  label: string;
  tokenRange: [number, number];
  description: string;         // Developer track only
}

export const segments: ContextSegmentData[] = [/* ... */];
export const presets: PresetData[] = [/* ... */];
export const degradationStages: DegradationStage[] = [/* ... */];
export const conversationTurnTypes: ConversationTurnType[] = [/* ... */];
```

Populate the data from the segment data table, presets table, and degradation stages table defined earlier in this spec. The build agent should transcribe the values directly.

---

## Accessibility Requirements

In addition to the general accessibility requirements from the frontend skills review:

- **Bar segments:** Each segment must have `role="img"` and an `aria-label` describing the segment name, token count, and percentage. Example: `aria-label="System Prompt: approximately 5,000 tokens, 2.5% of context window"`.
- **Sliders:** Use native `<input type="range">` with visible `<label>` elements. Include `aria-valuetext` that reads the token impact: `aria-valuetext="2 MCP servers, approximately 12,000 tokens"`.
- **Degradation stage:** Announce stage changes via an `aria-live="polite"` region. When the stage changes (e.g., from "Healthy" to "Early degradation"), screen readers should announce it.
- **Compaction animation:** The compaction sequence should be accompanied by an `aria-live="assertive"` announcement: "Conversation compacted. Approximately 50% of conversation tokens freed."
- **Colour-blind safety:** The degradation gradient uses opacity (not colour change alone). Each degradation stage also has a text label badge. Segment colours in the bar must be distinguishable by colour-blind users — use the colour palette check from the design guidelines. Include the segment legend (with names) for clarity.
- **Keyboard navigation:** All controls must be reachable via Tab. The "Add turn" button, preset buttons, sliders, and reset button should follow a logical tab order (left to right, top to bottom). The compaction button (when visible) should be in the natural tab flow.

---

## Acceptance Criteria

1. **Proportional bar renders correctly** with all 8 segments (system prompt, built-in tools, CLAUDE.md, MCP tools, skills, environment, conversation, response buffer) plus available space.
2. **Segment widths are proportional** to token counts and update smoothly when controls change.
3. **All sliders work** and update the bar in real-time. Token impact is shown next to each slider value.
4. **Three presets** (Minimal, Moderate, Heavy) correctly set all slider values and update the bar.
5. **"Add turn" button** adds a conversation turn with visible token count, growing the conversation segment.
6. **Degradation overlay appears** at 50%+ usage and intensifies through four stages with correct U-shape gradient.
7. **Degradation stage badge** updates correctly and is announced to screen readers.
8. **Compaction animation** triggers at 90%+ (auto on general track, button on developer track), shrinks conversation to ~50%, resets degradation, shows "Compacted" badge.
9. **Tooltips work** on all segments (hover on desktop, tap on mobile) showing segment name, tokens, percentage, and description.
10. **Two-track presentation** is correct: general track hides developer-only controls and content; developer track shows everything.
11. **Session handoff prompt** is displayed prominently with a working copy-to-clipboard button.
12. **Developer-only content** (CLAUDE.md compact instructions, response buffer section, manual compaction commands) is visible only on developer track.
13. **Educational accordion sections** expand/collapse correctly with smooth animation.
14. **Responsive layout** works at 320px, 640px, 768px, and 1024px widths. Mobile legend appears when segment labels are hidden.
15. **Reduced motion** is respected: all animations disabled or replaced with instant state changes.
16. **Keyboard navigation** works for all interactive elements (sliders, buttons, presets, accordions).
17. **All text is UK English** throughout (behaviour not behavior, summarised not summarized, colour not color in UI text).
18. **Caveat text** ("exact numbers vary") is visible near the simulator at all times.
19. **Performance:** Slider interactions are smooth at 60fps. No jank during segment resize animations. Derived state is computed during render, not in useEffect.
20. **Content data** is defined in a separate TypeScript data file, not hard-coded in JSX.

---

## Build Agent Checklist

### Frontend Quality Checklist

**Typography**
- [ ] Body text >= 16px (1rem), using rem units
- [ ] Max line length: 65ch for body text
- [ ] Fluid type (clamp) on headings; fixed sizes on UI controls
- [ ] Font stacks include size-adjusted fallback
- [ ] No generic fonts (Inter, Roboto, etc.) unless explicitly specified

**Colour & Theming**
- [ ] All custom colours defined in OKLCH via CSS variables
- [ ] Neutrals tinted towards brand hue (not pure grey)
- [ ] No pure black (#000) or pure white (#fff)
- [ ] Dark mode tested and functional (if applicable to section)
- [ ] All text meets WCAG AA contrast (4.5:1 body, 3:1 large/UI)

**Layout & Spacing**
- [ ] Spacing values from the 4pt grid (4, 8, 12, 16, 24, 32, 48, 64, 96)
- [ ] Visual hierarchy uses 2+ dimensions (size, weight, colour, space)
- [ ] No nested cards
- [ ] No identical repeating card grids

**Motion & Animation**
- [ ] Only `transform` and `opacity` animated (no width/height/top/left)
- [ ] Timing follows 100/300/500 rule
- [ ] Easing uses exponential curves (not default `ease` or bounce)
- [ ] `prefers-reduced-motion` handled (crossfade fallback or disable)
- [ ] Exit animations faster than entrances
- [ ] Motion used via Tailwind transitions where CSS suffices; Motion library only for layout/enter/exit

**Interaction**
- [ ] All 8 interactive states designed (default, hover, focus, active, disabled, loading, error, success)
- [ ] `:focus-visible` ring on all interactive elements (2-3px, offset, 3:1 contrast)
- [ ] Touch targets >= 44px
- [ ] Copy-to-clipboard on every prompt/template/code block
- [ ] Skeleton screens for loading states (not generic spinners)

**Accessibility**
- [ ] Semantic HTML (headings, landmarks, labels)
- [ ] Skip link present
- [ ] Keyboard navigation tested (Tab, Enter, Escape, Arrows)
- [ ] `aria-expanded`, `aria-controls` on accordions/collapsibles
- [ ] `aria-label` on icon-only buttons
- [ ] Images have `alt` text (or `alt=""` for decorative)
- [ ] Never `outline: none` without `:focus-visible` replacement

**Performance**
- [ ] No barrel file imports (direct imports from source)
- [ ] Shiki lazy-loaded (not in initial bundle)
- [ ] Derived state computed during render (no useEffect for derived values)
- [ ] `content-visibility: auto` on long scrollable content
- [ ] Passive event listeners on scroll/touch handlers
- [ ] Static JSX hoisted outside components where possible

**Responsive**
- [ ] Mobile-first (base styles for mobile, min-width queries for larger)
- [ ] Tested at 320px, 640px, 768px, 1024px widths
- [ ] No critical functionality hidden on mobile
- [ ] Hover-dependent features have touch alternatives
- [ ] Safe area insets handled for mobile

**UX Writing & Content**
- [ ] UK English throughout (spelling, grammar, currency, date format)
- [ ] Button labels use verb + object pattern
- [ ] Error messages answer: what, why, how to fix
- [ ] Consistent terminology (no synonyms for the same action)
- [ ] Empty states are actionable, not just "Nothing here"

**Code Quality**
- [ ] Tailwind utility classes only (no CSS modules or styled-components)
- [ ] `cn()` utility for conditional class merging
- [ ] `@/` path alias for all imports
- [ ] Components composed from shadcn primitives (not mega-components)
- [ ] Content defined as typed TS objects, not hard-coded JSX

### Section-Specific Checklist

- [ ] All 8 segments render in the proportional bar with correct default proportions
- [ ] Slider controls update segment widths in real-time with smooth animation
- [ ] Three presets (Minimal, Moderate, Heavy) work correctly
- [ ] "Add turn" button grows conversation segment with randomised token counts
- [ ] Degradation overlay renders U-shape gradient and intensifies through 4 stages
- [ ] Degradation stage badge updates and is announced to screen readers (`aria-live`)
- [ ] Compaction animation triggers, shrinks conversation, resets degradation, shows badge
- [ ] Tooltips show segment details on hover (desktop) and tap (mobile)
- [ ] General track hides: Skills slider, Tool Search toggle, compaction button, response buffer section, developer tips 6-12, manual compaction detail
- [ ] Developer track shows all controls and content
- [ ] Session handoff prompt has a working copy-to-clipboard button
- [ ] CLAUDE.md compact instructions have a working copy-to-clipboard button (developer track only)
- [ ] Caveat text is always visible near the simulator
- [ ] Mobile legend appears when segment labels are hidden (< 640px)
- [ ] Token calculations are correct (especially Tool Search capping MCP at 20K)
- [ ] `useReducedMotion` hook applied to all Motion components
- [ ] All educational accordion sections expand/collapse with correct aria attributes
