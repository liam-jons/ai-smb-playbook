# Spec 1.10 — Codebase Mapping

> **Phase 2 build agent:** Agent 4 — Developer Track Sections
> **Track:** Developer

## Purpose

This section teaches Phew!'s developers how to use the gsd-codebase-mapper to automatically produce a structured understanding of any codebase they work on. It explains the mapper's parallel subagent architecture (4 agents running simultaneously, each writing documents directly), walks through the 7 output documents, and shows how the output becomes the foundation for the `/docs` structure described in section 1.9. For Phew!, this is directly applicable to their WordPress and ASP.NET/C# projects — particularly brownfield codebases where documentation may be sparse or outdated.

This section also serves as a practical demonstration of the parallel subagent pattern covered conceptually in earlier sections. By explaining how the mapper orchestrator spawns 4 focused agents, each with its own full 200k token context window, it reinforces the "break work into atomic subtasks" principle from the training.

## Source References

| File | Path | What to extract |
|------|------|-----------------|
| map-codebase command (source context) | `.planning/source-context/map-codebase.md` | The original command definition — process steps, success criteria, argument hint, allowed tools. Shows the orchestrator's role: spawn agents, collect confirmations, verify output, commit. |
| map-codebase command (starter kit) | `starter-kit/gsd-mapper/command/map-codebase.md` | Identical to above — the command file included in the starter kit. Confirm content matches. |
| map-codebase workflow | `starter-kit/gsd-mapper/workflow/map-codebase.md` | The detailed workflow file referenced by the command. Contains: model profile resolution, check for existing map, directory creation, agent spawn prompts (exact text for each of the 4 agents), confirmation collection, verification, commit, and next steps. This is the authoritative source for how the orchestrator works. |
| gsd-codebase-mapper agent | `starter-kit/gsd-mapper/agent/gsd-codebase-mapper.md` | The agent definition. Contains: role description, 4 focus areas (tech, arch, quality, concerns), philosophy (document quality over brevity, always include file paths, write current state only, be prescriptive), exploration commands for each focus area, the "why this matters" section explaining how other commands consume these documents, template filling instructions, and critical rules (write directly, return confirmation only). |
| STACK.md template | `starter-kit/gsd-mapper/templates/codebase/stack.md` | Template + guidelines + good examples for the technology stack document. Covers: languages, runtime, frameworks, key dependencies, configuration, platform requirements. |
| INTEGRATIONS.md template | `starter-kit/gsd-mapper/templates/codebase/integrations.md` | Template + guidelines + good examples for external integrations. Covers: APIs, data storage, auth, monitoring, CI/CD, environment config, webhooks. |
| ARCHITECTURE.md template | `starter-kit/gsd-mapper/templates/codebase/architecture.md` | Template + guidelines + good examples for architecture analysis. Covers: pattern overview, layers, data flow, key abstractions, entry points, error handling, cross-cutting concerns. |
| STRUCTURE.md template | `starter-kit/gsd-mapper/templates/codebase/structure.md` | Template + guidelines + good examples for physical file organisation. Covers: directory layout (ASCII tree), directory purposes, key file locations, naming conventions, where to add new code, special directories. |
| CONVENTIONS.md template | `starter-kit/gsd-mapper/templates/codebase/conventions.md` | Template + guidelines + good examples for coding conventions. Covers: naming patterns, code style, import organisation, error handling, logging, comments, function/module design. |
| TESTING.md template | `starter-kit/gsd-mapper/templates/codebase/testing.md` | Template + guidelines + good examples for testing patterns. Covers: framework, file organisation, test structure, mocking, fixtures, coverage, test types, common patterns. |
| CONCERNS.md template | `starter-kit/gsd-mapper/templates/codebase/concerns.md` | Template + guidelines + good examples for codebase concerns. Covers: tech debt, known bugs, security, performance, fragile areas, scaling limits, dependencies at risk, missing features, test coverage gaps. |
| Training summary (Meeting 2) | `.planning/source-context/phew-training-claude-code-and-qa-summary.md` | References to: multi-agent parallel processing, each agent uses separate 200k token allocation, automatic architecture documentation generation, tech debt identification (21kb concerns file generated). Use these to connect the mapper to what was discussed in the training. |
| Initial thoughts | `.planning/source-context/phew-initial-thoughts-for-meeting-follow-up.md` | Topics: "Using agents to document and maintain codebase docs", "Creating a documentation setup which is just for Claude (i.e., LLM-ready and optimised)". The mapper is the practical answer to both. |
| Doc structure source | `.planning/source-context/suggestions-related-to-doc-structure.md` | The OpenAI/Reddit approach to agent-readable documentation. Section 1.10 should explain how the mapper's output feeds into this structure — the 7 documents become the starting point for the `/docs` directory described in section 1.9. |
| App tech stack | `.planning/research/app-tech-stack.md` | UI component decisions: shadcn/ui components, Shiki for syntax highlighting, copy-to-clipboard pattern. |
| Frontend skills review | `.planning/research/frontend-skills-review.md` | Design guidelines and the full Build Agent Checklist. |

## Content Outline

### Opening: What Is Codebase Mapping?

A brief introduction (2-3 paragraphs) explaining the concept:

- Most codebases — especially ones that have grown organically over years — lack comprehensive, up-to-date documentation. When you ask Claude to work on a project, it can only act on what it can see in its context window. If the codebase has no documentation, Claude has to explore from scratch every session.
- Codebase mapping solves this by using AI agents to systematically explore a codebase and produce structured documentation. The output becomes a permanent reference — both for Claude and for the human team.
- The gsd-codebase-mapper is a ready-to-use tool included in the starter kit. It produces 7 structured documents covering every aspect of a codebase: technology stack, integrations, architecture, file structure, coding conventions, testing patterns, and concerns (technical debt, bugs, security issues).

**Phew! context note:** This is directly relevant to Phew!'s existing projects. Whether it is a WordPress site, an ASP.NET/C# application, or a new project, running the mapper creates a comprehensive baseline understanding that persists across sessions.

### The 7 Output Documents

Present each document with: what it covers, why it matters, and a representative snippet from the template showing the structure. Use an accordion or collapsible layout so all 7 are accessible without overwhelming the page.

**1. STACK.md — Technology Stack**
- What it covers: Languages, runtime, frameworks, key dependencies, build tooling, platform requirements.
- Why it matters: Tells Claude what technologies run the codebase, so it makes recommendations compatible with the existing stack.
- Example structure snippet (from the template):
```markdown
# Technology Stack

**Analysis Date:** 2026-02-14

## Languages

**Primary:**
- TypeScript 5.3 - All application code

**Secondary:**
- JavaScript - Build scripts, config files

## Runtime

**Environment:**
- Node.js 20.x (LTS)

**Package Manager:**
- npm 10.x
- Lockfile: `package-lock.json` present

## Frameworks

**Core:**
- Next.js 14 - Full-stack React framework

**Testing:**
- Vitest 1.0 - Unit tests
```

**2. INTEGRATIONS.md — External Integrations**
- What it covers: APIs, databases, file storage, auth providers, monitoring, CI/CD, webhooks.
- Why it matters: Documents what lives outside the codebase — external services, credentials (environment variable names, not values), and integration patterns.
- Example structure snippet showing an API integration entry and a database entry.

**3. ARCHITECTURE.md — Architecture**
- What it covers: Overall pattern (e.g., "monolithic MVC", "serverless API"), conceptual layers, data flow, key abstractions, entry points, error handling, cross-cutting concerns.
- Why it matters: Tells Claude how the code is organised at a conceptual level — where to put new features, how layers depend on each other, and what patterns to follow.
- Example structure snippet showing a layer definition and a data flow sequence.

**4. STRUCTURE.md — Codebase Structure**
- What it covers: Directory layout (ASCII tree), directory purposes, key file locations, naming conventions, where to add new code, special/generated directories.
- Why it matters: Answers "where do I put this?" — the most common question when adding new code. Claude can navigate directly to the right location.
- Example structure snippet showing the ASCII tree format and a "Where to Add New Code" entry.

**5. CONVENTIONS.md — Coding Conventions**
- What it covers: Naming patterns (files, functions, variables, types), code style (formatting, linting), import organisation, error handling, logging, comments, function/module design.
- Why it matters: Ensures Claude writes code that matches the existing style. Prescriptive guidance ("Use camelCase for functions") rather than descriptive ("Some functions use camelCase").
- Example structure snippet showing naming patterns and import order.

**6. TESTING.md — Testing Patterns**
- What it covers: Test framework and runner, file organisation, test structure (describe/it patterns), mocking approach, fixtures, coverage requirements, test types (unit/integration/E2E).
- Why it matters: Claude needs to know how tests are written in this project so it can add matching tests for new code. Shows actual patterns, not theoretical best practices.
- Example structure snippet showing a test structure pattern and mocking example.

**7. CONCERNS.md — Codebase Concerns**
- What it covers: Technical debt, known bugs, security considerations, performance bottlenecks, fragile areas, scaling limits, dependencies at risk, missing features, test coverage gaps.
- Why it matters: This is the most actionable document. Issues identified here can become future work items. Each concern includes file paths, impact assessment, and a suggested fix approach.
- Example structure snippet showing a tech debt entry and a security consideration.

**Design note for the 7-document section:** Use shadcn Accordion with each document as an AccordionItem. The trigger shows the document name and a one-line summary. Expanding reveals the description, "why it matters" text, and a syntax-highlighted code block showing the example structure snippet. Each code block has a copy button. Include a callout noting that the full templates are available in the starter kit.

### How It Works: The 4-Agent Parallel Architecture

This is the most conceptually important part of the section. It demonstrates the parallel subagent pattern in practice.

**Explain the architecture with a clear visual or structured breakdown:**

The mapper uses an orchestrator + 4 specialised agents pattern:

| Agent | Focus Area | Documents Produced |
|-------|-----------|-------------------|
| Agent 1 | **Tech** — technology stack and external integrations | STACK.md, INTEGRATIONS.md |
| Agent 2 | **Arch** — architecture and file structure | ARCHITECTURE.md, STRUCTURE.md |
| Agent 3 | **Quality** — coding conventions and testing patterns | CONVENTIONS.md, TESTING.md |
| Agent 4 | **Concerns** — technical debt and issues | CONCERNS.md |

**Key concepts to explain:**

1. **Each agent gets its own full 200k token context.** The orchestrator does not try to hold the entire codebase in one context window — it delegates to specialised agents, each of which can explore deeply within its focus area. This is the same principle covered in the training: breaking work into subtasks gives each subtask the full token allocation.

2. **Agents write documents directly.** Each agent writes its output directly to `.planning/codebase/`. The orchestrator never receives the document contents — only a brief confirmation with file names and line counts. This keeps the orchestrator's context clean and avoids the bottleneck of passing large documents through a single context.

3. **Agents run in parallel.** All 4 agents are spawned simultaneously using background tasks. This means the mapping completes in roughly the time it takes the slowest agent, not the sum of all agents. For a typical codebase, this is a few minutes.

4. **The orchestrator verifies and commits.** After all agents complete, the orchestrator checks that all 7 documents exist, verifies they have content (not empty), and commits them to version control.

**Include a simplified flow diagram using text/ASCII or a clear step-by-step:**

```
1. You run:  /gsd:map-codebase
2. Orchestrator creates .planning/codebase/ directory
3. Orchestrator spawns 4 agents in parallel:
   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
   │ Agent 1  │  │ Agent 2  │  │ Agent 3  │  │ Agent 4  │
   │  (tech)  │  │  (arch)  │  │(quality) │  │(concerns)│
   │          │  │          │  │          │  │          │
   │ Explores │  │ Explores │  │ Explores │  │ Explores │
   │ stack,   │  │ patterns,│  │ style,   │  │ debt,    │
   │ deps,    │  │ layers,  │  │ linting, │  │ bugs,    │
   │ APIs     │  │ files    │  │ tests    │  │ security │
   │          │  │          │  │          │  │          │
   │ Writes:  │  │ Writes:  │  │ Writes:  │  │ Writes:  │
   │ STACK.md │  │ARCH...md │  │CONV...md │  │CONC...md │
   │ INTEG.md │  │STRUC..md │  │TEST...md │  │          │
   └──────────┘  └──────────┘  └──────────┘  └──────────┘
4. Orchestrator collects confirmations (NOT contents)
5. Orchestrator verifies all 7 documents exist
6. Orchestrator commits the codebase map
```

**Why this matters for Phew!:** This is the same pattern that built this playbook. The playbook itself was created by parallel agents, each working from a spec. The mapper uses the same approach at a smaller scale — 4 agents instead of 6, exploring code instead of writing content, but the principle is identical.

### Running the Mapper: Step-by-Step

A practical, numbered guide:

**Prerequisites:**
- Claude Code installed and running in the project directory
- The gsd-codebase-mapper files installed (agent file, command file, workflow file) — see the starter kit

**Step 1: Navigate to your project**
Open Claude Code in the root of the project you want to map.

**Step 2: Run the command**
```
/gsd:map-codebase
```

Optionally, you can specify a focus area if you only want to map part of the codebase:
```
/gsd:map-codebase api
```

**Step 3: Wait for agents to complete**
The orchestrator will spawn 4 agents and show progress. This typically takes 2-5 minutes depending on codebase size.

**Step 4: Review the output**
The mapper creates `.planning/codebase/` with 7 documents. Review each one:
```bash
ls -la .planning/codebase/
cat .planning/codebase/STACK.md
```

**Step 5: Edit and refine**
The generated documents are a starting point, not a finished product. Review each document and:
- Correct any inaccuracies (the mapper does its best, but may miss context)
- Add information the mapper could not discover (business context, deployment credentials locations, team conventions not captured in code)
- Remove sections that are not applicable

**When to run the mapper:**
- When onboarding to an unfamiliar codebase (the primary use case for Phew!)
- Before major refactoring (understand current state first)
- After significant changes (refresh the codebase understanding)
- When the existing documentation is outdated or missing

**When to skip the mapper:**
- Greenfield projects with no code yet (nothing to map)
- Trivial codebases with fewer than 5 files

### Connecting to the /docs Structure (Section 1.9)

Explain how the mapper's output feeds into the documentation structure from section 1.9:

- The 7 mapper documents are a raw analysis — a snapshot of the codebase at a point in time.
- The `/docs` structure from section 1.9 is the long-term, maintained documentation system.
- The mapper's output becomes the seed content for the `/docs` structure:

| Mapper Output | Feeds Into |
|--------------|------------|
| STACK.md | `/docs` root or `CLAUDE.md` tech stack section |
| INTEGRATIONS.md | `docs/integrations/` |
| ARCHITECTURE.md | `docs/architecture/` |
| STRUCTURE.md | `CLAUDE.md` (directory overview) |
| CONVENTIONS.md | `docs/conventions/` |
| TESTING.md | `docs/conventions/` or dedicated testing docs |
| CONCERNS.md | Tech debt tracker, sprint backlog, or `docs/exec-plans/tech-debt-tracker.md` |

- After running the mapper, move the relevant content into your `/docs` structure and update `CLAUDE.md` to point to it.
- Re-run the mapper periodically and diff the output against your maintained docs to catch drift.

**Key principle (from the training):** "From the agent's point of view, anything it cannot access in-context effectively does not exist." The mapper creates the documentation that makes your codebase visible to Claude.

### How Other Commands Use the Mapper Output

Briefly explain that the codebase documents are not just for human reference — they are consumed by other Claude commands and workflows:

| When Claude is... | It loads... |
|-------------------|------------|
| Planning UI/frontend work | CONVENTIONS.md, STRUCTURE.md |
| Planning API/backend work | ARCHITECTURE.md, CONVENTIONS.md |
| Planning database/schema changes | ARCHITECTURE.md, STACK.md |
| Writing tests | TESTING.md, CONVENTIONS.md |
| Working with external integrations | INTEGRATIONS.md, STACK.md |
| Refactoring or cleanup | CONCERNS.md, ARCHITECTURE.md |
| Setting up configuration | STACK.md, STRUCTURE.md |

This means the quality of the mapper output directly affects the quality of Claude's future work on the project.

## Interaction Design

### Components Used

| Component | Source | Usage |
|-----------|--------|-------|
| `Accordion` | shadcn/ui | 7 output documents — each as a collapsible item |
| `Card` | shadcn/ui | Architecture overview panel, "when to use" guidance |
| `Alert` | shadcn/ui | Key principle callouts, Phew!-specific context notes |
| `Badge` | shadcn/ui | Agent labels (Agent 1: Tech, Agent 2: Arch, etc.), document type indicators |
| `Separator` | shadcn/ui | Visual dividers between major sections |
| `Tabs` | shadcn/ui | Optional — could be used for the mapping table (mapper output -> docs structure) if the content benefits from tabbed presentation |
| `CodeBlock` (custom) | Shiki via react-shiki | Syntax-highlighted code blocks for command examples, template snippets, and the ASCII flow diagram |
| `CopyButton` (custom) | Native Clipboard API | Copy button on every code block and prompt |

### Layout

- **Mobile (< 640px):** Single column. Accordion items stack naturally. The architecture diagram (ASCII text) uses horizontal scroll if needed. Code blocks use full width with horizontal scroll for overflow.
- **Tablet (640px-1023px):** Single column with wider content area. Tables display inline.
- **Desktop (1024px+):** Single column content with max-width 65ch for body text. Tables and code blocks can extend beyond the text column if needed (up to the container width). The agent architecture diagram has room to display cleanly.

### Key Interactions

1. **Accordion (7 documents):** Each document is a collapsible AccordionItem. Default state: all collapsed. Clicking expands one item (single-expand mode recommended to avoid overwhelming the view). Each expanded item contains: description, "why it matters", and a syntax-highlighted example snippet with copy button.
2. **Code blocks:** All command examples (`/gsd:map-codebase`, `ls -la .planning/codebase/`, etc.) and template snippets are syntax-highlighted with Shiki and include a copy button.
3. **Architecture diagram:** The ASCII-style parallel agent flow diagram is displayed as a code block (language: `text` or `plaintext`) with a copy button. On mobile, it scrolls horizontally.

### Animation / Motion

- **Accordion expand/collapse:** Use shadcn's built-in Radix animation. Optionally supplement with Motion `layout` animation for smoother content-height transitions. Respect `prefers-reduced-motion`.
- **No other animations.** This is a content-heavy reference section — animation should serve function (revealing content), not decoration.

## Copyable Content

All of the following must have a copy-to-clipboard button:

### 1. The Mapper Command
```
/gsd:map-codebase
```

### 2. The Mapper Command with Focus Area
```
/gsd:map-codebase api
```

### 3. Review Output Commands
```bash
ls -la .planning/codebase/
```

### 4. Each Template Snippet
Each of the 7 example structure snippets shown in the accordion should be copyable. These are illustrative excerpts from the templates, not the full templates — include a note directing users to the starter kit for the full template files.

### 5. The Architecture Diagram
The text-based parallel agent flow diagram should be copyable (useful for including in documentation or explanations).

## Two-Track Considerations

This section is **Developer track only**. It assumes the reader:
- Has access to Claude Code (terminal or IDE)
- Is comfortable running commands in a terminal
- Understands what a codebase is and why documentation matters

**General track users** should not see this section in the navigation. If a general track user somehow navigates here (e.g., via a direct link), the content should still be understandable but may use terminology they are not familiar with.

**Cross-references to general track content:**
- The parallel subagent concept is introduced at a high level in section 1.3 (Session Management — breaking tasks into subtasks). This section provides the concrete implementation.
- The context window implications (each agent gets its own 200k context) connect to section 1.2 (How Context Works).

## Acceptance Criteria

1. The section clearly explains what the gsd-codebase-mapper is and what it produces (7 structured documents).
2. All 7 output documents are described with: what they cover, why they matter, and a representative template snippet — presented in a collapsible accordion layout.
3. The 4-agent parallel architecture is explained with a clear visual (ASCII diagram or structured layout) showing how agents are spawned, what each explores, and what each produces.
4. The "each agent gets its own 200k token context" concept is explicitly stated and connected to the training content about breaking tasks into subtasks.
5. The "agents write directly, orchestrator only receives confirmations" pattern is explained clearly — this is a key design insight for context management.
6. A step-by-step guide for running the mapper is provided with numbered steps, prerequisites, and guidance on when to use (and skip) the mapper.
7. The connection to section 1.9 (Documentation Structure) is clearly made: mapper output feeds into the `/docs` structure, with a mapping table showing which documents go where.
8. The "How Other Commands Use the Output" table is included, showing that codebase documents are consumed by Claude workflows — reinforcing why document quality matters.
9. All command examples and template snippets have copy-to-clipboard buttons.
10. Template snippets accurately reflect the actual templates in `starter-kit/gsd-mapper/templates/codebase/` — do not invent content that is not in the source files.
11. Content is contextualised for Phew!: references to WordPress and ASP.NET/C# projects, SMB-appropriate language, practical rather than theoretical.
12. UK English is used throughout.
13. The section loads correctly within the developer track navigation and does not depend on any other section being rendered.
14. The ASCII architecture diagram displays correctly on mobile (horizontal scroll) and desktop (inline).
15. Semantic HTML is used: proper heading hierarchy, accordion uses `aria-expanded`/`aria-controls`, code blocks are accessible.

## Build Agent Checklist

### Frontend Quality Checklist

**Typography**
- [ ] Body text >= 16px (1rem), using rem units
- [ ] Max line length: 65ch for body text
- [ ] Fluid type (clamp) on headings; fixed sizes on UI controls
- [ ] Font stacks include size-adjusted fallback
- [ ] No generic fonts (Inter, Roboto, etc.) unless explicitly specified

**Colour & Theming**
- [ ] All custom colours defined in OKLCH via CSS variables
- [ ] Neutrals tinted towards brand hue (not pure grey)
- [ ] No pure black (#000) or pure white (#fff)
- [ ] Dark mode tested and functional (if applicable to section)
- [ ] All text meets WCAG AA contrast (4.5:1 body, 3:1 large/UI)

**Layout & Spacing**
- [ ] Spacing values from the 4pt grid (4, 8, 12, 16, 24, 32, 48, 64, 96)
- [ ] Visual hierarchy uses 2+ dimensions (size, weight, colour, space)
- [ ] No nested cards
- [ ] No identical repeating card grids

**Motion & Animation**
- [ ] Only `transform` and `opacity` animated (no width/height/top/left)
- [ ] Timing follows 100/300/500 rule
- [ ] Easing uses exponential curves (not default `ease` or bounce)
- [ ] `prefers-reduced-motion` handled (crossfade fallback or disable)
- [ ] Exit animations faster than entrances
- [ ] Motion used via Tailwind transitions where CSS suffices; Motion library only for layout/enter/exit

**Interaction**
- [ ] All 8 interactive states designed (default, hover, focus, active, disabled, loading, error, success)
- [ ] `:focus-visible` ring on all interactive elements (2-3px, offset, 3:1 contrast)
- [ ] Touch targets >= 44px
- [ ] Copy-to-clipboard on every prompt/template/code block
- [ ] Skeleton screens for loading states (not generic spinners)

**Accessibility**
- [ ] Semantic HTML (headings, landmarks, labels)
- [ ] Skip link present
- [ ] Keyboard navigation tested (Tab, Enter, Escape, Arrows)
- [ ] `aria-expanded`, `aria-controls` on accordions/collapsibles
- [ ] `aria-label` on icon-only buttons
- [ ] Images have `alt` text (or `alt=""` for decorative)
- [ ] Never `outline: none` without `:focus-visible` replacement

**Performance**
- [ ] No barrel file imports (direct imports from source)
- [ ] Shiki lazy-loaded (not in initial bundle)
- [ ] Derived state computed during render (no useEffect for derived values)
- [ ] `content-visibility: auto` on long scrollable content
- [ ] Passive event listeners on scroll/touch handlers
- [ ] Static JSX hoisted outside components where possible

**Responsive**
- [ ] Mobile-first (base styles for mobile, min-width queries for larger)
- [ ] Tested at 320px, 640px, 768px, 1024px widths
- [ ] No critical functionality hidden on mobile
- [ ] Hover-dependent features have touch alternatives
- [ ] Safe area insets handled for mobile

**UX Writing & Content**
- [ ] UK English throughout (spelling, grammar, currency, date format)
- [ ] Button labels use verb + object pattern
- [ ] Error messages answer: what, why, how to fix
- [ ] Consistent terminology (no synonyms for the same action)
- [ ] Empty states are actionable, not just "Nothing here"

**Code Quality**
- [ ] Tailwind utility classes only (no CSS modules or styled-components)
- [ ] `cn()` utility for conditional class merging
- [ ] `@/` path alias for all imports
- [ ] Components composed from shadcn primitives (not mega-components)
- [ ] Content defined as typed TS objects, not hard-coded JSX
