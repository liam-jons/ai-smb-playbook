# Spec 1.4 — Skills, Extensions & the Decision Tree

> **Phase 2 build agent:** Agent 3 — Skills, Extensions, Governance & Brand
> **Track:** Both (General + Developer)
> **Route:** `/:track/skills-extensions`

---

## Purpose

This section is the playbook's navigation hub for extension mechanisms. A user arriving here wants to answer the question: **"I want Claude to do something it doesn't do out of the box — what should I use?"**

The section provides:
1. An interactive decision tree ("I want to..." entry points) that routes users to the right extension mechanism
2. A reference catalogue of every extension mechanism — what it is, when to use it, how to set it up, what it costs in context, and where it works
3. Comparison tables adapted from the official Anthropic documentation, contextualised for Phew!'s setup (Claude Teams, Desktop, Code)
4. An availability matrix showing which features work on which platforms

The General track focuses on what non-technical users can do via claude.ai and Claude Desktop (skills, Projects, admin-provisioned tools). The Developer track adds the full technical taxonomy including Claude Code-only features (CLAUDE.md, commands, subagents, agent teams, hooks, MCP, plugins).

---

## Source References

| File | Path | What to extract |
|------|------|-----------------|
| Extension options (PRIMARY) | `.planning/source-context/claude-code-capabilities-extension-options.md` | Full extension taxonomy, comparison tables, context cost table, loading behaviour, feature layering rules, combination patterns |
| Capabilities audit | `.planning/research/capabilities-audit.md` | New mechanisms (LSP, prompt/agent hooks, persistent memory), comparison table verification, decision tree branch points, gotchas, supplementary detail from deeper docs |
| Command availability | `.planning/research/command-availability.md` | Platform-by-platform breakdown, slash commands vs skills distinction, skill invocation mechanism on web/Desktop, packaging recommendations |
| App tech stack | `.planning/research/app-tech-stack.md` | Accordion-wizard hybrid pattern for decision tree, shadcn components, Motion animations |
| Frontend skills review | `.planning/research/frontend-skills-review.md` | Design guidelines, interaction patterns, accessibility requirements, build agent checklist |

**The build agent should read all five files.** The content outline below extracts and reorganises all relevant content so the build agent should not need to interpret the raw source documents, but reading them provides additional context for edge cases.

---

## Content Outline

### A. Section Introduction

**Heading:** "Skills, Extensions & the Decision Tree"

**Lead paragraph (both tracks):**
> Claude comes with powerful built-in tools for conversation, writing, analysis, and code. But its real power emerges when you extend it — teaching it your company's conventions, connecting it to your tools, or giving it specialised knowledge. This section helps you find the right extension mechanism for what you want to achieve.

**Key framing (both tracks):**
- Extensions range from "always-on context" (things Claude knows every session) to "on-demand capabilities" (things you or Claude can invoke when needed) to "background automation" (things that happen automatically on specific events)
- Not every mechanism is available on every platform — the decision tree and availability matrix below show what works where
- Phew! has Claude Teams licences for all staff and Claude Code access for developers — this section is written for that setup

---

### B. The Decision Tree — "I want to..."

This is the primary interactive element. It uses the accordion-wizard hybrid pattern (see Interaction Design section below).

#### Entry Points (Top-Level Accordion Items)

Each entry point is a user goal phrased as "I want to..." — expanding it reveals the recommended mechanism(s), with brief explanation and a link to the detailed reference card further down the page.

**Entry Point 1: "I want Claude to always follow certain rules"**
- **Recommended:** CLAUDE.md (Developer) / Custom instructions in a Project (General)
- **What it does:** Sets persistent conventions Claude follows every session — coding standards, tone of voice, formatting rules, project structure
- **Example for Phew!:** "Always use UK English. Never deploy to production without tests. Use our naming conventions for CSS classes."
- **Platform:** CLAUDE.md is Claude Code only. Projects with custom instructions work on claude.ai and Claude Desktop.
- **Link to:** CLAUDE.md reference card (Developer track) / Projects guidance (General track)

**Entry Point 2: "I want to give Claude specialist knowledge it can use when needed"**
- **Recommended:** Skills
- **What it does:** Gives Claude reusable knowledge, reference material, or workflows it can draw on when relevant. Like giving a colleague a reference manual they consult when needed, rather than memorising.
- **Example for Phew!:** A skill containing your brand voice guidelines that Claude uses when writing client-facing content. A skill with your API documentation that Claude references when answering questions about integrations.
- **Platform:** Works everywhere — claude.ai, Claude Desktop, Claude Code, CoWork
- **General track note:** Skills are the universal extension mechanism. Your admin can deploy skills to the whole team via the admin console. You can also upload skills individually via Settings > Capabilities.
- **Developer track note:** In Claude Code, skills are filesystem-based (`.claude/skills/` directory). You can invoke them explicitly with `/skill-name` or let Claude load them automatically based on task relevance.
- **Link to:** Skills reference card

**Entry Point 3: "I want to trigger a specific workflow with a command"**
- **Recommended:** Skills with slash command invocation (Developer) / Skills via natural language (General)
- **What it does:** Creates a repeatable workflow you can trigger on demand — like a macro or script, but powered by Claude's reasoning
- **Example for Phew!:** `/review` runs your code review checklist. `/deploy` executes your deployment workflow. `/handoff` creates a structured session summary.
- **Platform:** Slash commands (`/name`) are Claude Code and CoWork only. On claude.ai and Claude Desktop, the same skills are triggered via natural language — Claude matches your request to the skill's description.
- **General track note:** You don't type a command. Simply describe what you want ("I need to hand this session off to Sarah") and Claude automatically matches it to the right skill. The quality of the skill's description determines how reliably this works.
- **Link to:** Skills reference card (invocation section)

**Entry Point 4: "I want Claude to connect to an external service"**
- **Recommended:** MCP (Model Context Protocol)
- **What it does:** Connects Claude to external tools and data sources — databases, APIs, browsers, project management tools
- **Example for Phew!:** Connect to your staging database to query data. Connect to Slack to post updates. Use a browser tool to test websites.
- **Platform:** Claude Code (full MCP support). Claude Desktop has MCP support via settings. claude.ai has Connectors (a managed form of MCP). CoWork has plugin-provided integrations.
- **General track note:** On claude.ai, look for "Connectors" in your settings — these are pre-built, managed connections to services like Google Drive, Notion, and Slack. Your admin manages which Connectors are available.
- **Developer track note:** In Claude Code, you configure MCP servers in `.claude/settings.json`. Each server's tool definitions load into context at session start, consuming up to 10% of your context window. Disconnect servers you're not actively using.
- **Link to:** MCP reference card

**Entry Point 5: "I want Claude to run a task separately without cluttering my conversation"**
- **Recommended:** Subagents (Developer only)
- **What it does:** Spawns an isolated worker that does the task in its own context window and returns only a summary. Your main conversation stays clean.
- **Example for Phew!:** "Research all the authentication patterns in our codebase and summarise them" — the subagent reads dozens of files but your conversation only gets the findings.
- **Platform:** Claude Code only
- **Link to:** Subagents reference card
- **Track:** Developer only (hidden from General track)

**Entry Point 6: "I want multiple Claude instances working together on a big task"**
- **Recommended:** Agent Teams (Developer only, experimental)
- **What it does:** Coordinates multiple independent Claude Code sessions that can communicate with each other, share findings, and divide work
- **Example for Phew!:** Three agents reviewing a pull request simultaneously — one checks security, one checks performance, one checks test coverage — then they share findings.
- **Platform:** Claude Code only (experimental, disabled by default)
- **Important note:** Agent Teams are experimental. Enable with `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`. Known limitations include no session resumption, one team per session, and limited terminal support.
- **Link to:** Agent Teams reference card
- **Track:** Developer only

**Entry Point 7: "I want something to happen automatically when Claude does specific things"**
- **Recommended:** Hooks (Developer only)
- **What it does:** Runs a script automatically when specific events occur — like running a linter after every file edit, or posting a Slack notification when Claude modifies critical files. No AI involved — purely deterministic.
- **Example for Phew!:** Automatically run ESLint after every file edit. Run tests before every commit. Post to a Slack channel when Claude modifies database schema files.
- **Platform:** Claude Code only
- **Link to:** Hooks reference card
- **Track:** Developer only

**Entry Point 8: "I want to package and share a set of extensions across projects"**
- **Recommended:** Plugins (Developer only)
- **What it does:** Bundles skills, hooks, subagents, and MCP servers into a single installable package that can be shared across repositories or distributed to others
- **Example for Phew!:** Package your team's code review skill, deployment hooks, and database MCP config into a single plugin that every developer installs.
- **Platform:** Claude Code only
- **Link to:** Plugins reference card
- **Track:** Developer only

**Entry Point 9: "I want better code intelligence — jump to definition, find references, type checking"**
- **Recommended:** LSP plugins (Developer only)
- **What it does:** Gives Claude real-time code intelligence through Language Server Protocol — automatic diagnostics after file edits, jump to definitions, find references, hover type info
- **Example for Phew!:** Install the TypeScript LSP plugin so Claude catches type errors immediately after editing files, without needing to run the compiler.
- **Platform:** Claude Code only (via plugin system)
- **Link to:** Plugins reference card (LSP section)
- **Track:** Developer only

---

### C. Platform Availability Matrix

Present as a responsive table. This is a key reference that users will return to.

| Feature | claude.ai | Claude Desktop | Claude Code | CoWork |
|---------|:---------:|:--------------:|:-----------:|:------:|
| **Skills (auto-invocation)** | Yes | Yes | Yes | Yes |
| **Skills (slash command `/name`)** | -- | -- | Yes | Yes (via plugins) |
| **Skills (admin-provisioned)** | Yes | Yes | Yes | Yes |
| **Skills (ZIP upload)** | Yes | Yes | -- (filesystem) | -- |
| **Projects (custom instructions)** | Yes | Yes | -- | -- |
| **CLAUDE.md** | -- | -- | Yes | -- |
| **MCP servers** | Connectors (managed) | Yes (settings) | Yes (full) | Via plugins |
| **Subagents** | -- | -- | Yes | -- |
| **Agent Teams** | -- | -- | Yes (experimental) | -- |
| **Hooks** | -- | -- | Yes | -- |
| **Plugins** | -- | -- | Yes | -- |
| **LSP servers** | -- | -- | Yes (via plugins) | -- |
| **Slash commands** | -- | -- | Yes | Yes (via plugins) |

**Notes to display below the matrix:**
- "Yes" means the feature is available and functional on that platform.
- "--" means the feature is not available on that platform.
- "Connectors (managed)" means claude.ai uses a managed, admin-configured version of MCP rather than direct server configuration.
- Phew! has Claude Teams licences for all staff. Custom skills require a Pro, Max, Team, or Enterprise plan with code execution enabled.
- Claude Desktop and claude.ai share the same skill system — skills uploaded on one are available on the other.
- CoWork is a separate autonomous agent mode within Claude Desktop, not the same as basic Desktop chat.

---

### D. Extension Mechanism Reference Cards

Each mechanism gets a "reference card" — a structured block containing everything a user needs to understand and start using it. Present these as expandable accordion sections below the decision tree.

#### D.1 — CLAUDE.md

**What it is:** A markdown file (named `CLAUDE.md`) that stores project context, conventions, and instructions. Claude reads it automatically at the start of every session.

**Track:** Developer (Claude Code only). General track users should see the "Projects with custom instructions" equivalent noted in D.2.

**When to use it:**
- Project conventions ("always use pnpm, not npm")
- Build commands and test instructions
- Architecture overview and key patterns
- "Never do X" rules
- Tech stack specifications
- Auth patterns and database schema references

**When NOT to use it:**
- Reference material Claude only needs sometimes (use a skill instead)
- Workflows triggered on demand (use a skill with slash command)
- Content that exceeds ~500 lines (move detail to skills or `/docs`)

**How it loads (context cost):**
- Full content loads at session start and is included in every request
- Additive: CLAUDE.md files from your working directory upwards all contribute
- Subdirectory CLAUDE.md files are discovered as Claude works in those directories
- **Cost guidance:** Keep under ~500 lines. If it's growing, move reference content to skills.

**Layering rules:**
- All levels contribute simultaneously (user-level, project-level, subdirectory-level)
- When instructions conflict, Claude uses judgement — more specific instructions typically take precedence
- Managed/enterprise-level CLAUDE.md is available for organisation-wide policies

**How to set up:**
1. Create a file called `CLAUDE.md` in your project root
2. Add your project conventions, build commands, and key context
3. Claude reads it automatically — no configuration needed

**Comparison with Skills:**

| Aspect | CLAUDE.md | Skill |
|--------|-----------|-------|
| Loads | Every session, automatically | On demand (description at start, full content when used) |
| Can include files | Yes, with `@path` imports | Yes, with `@path` imports |
| Can trigger workflows | No | Yes, with `/<name>` |
| Best for | "Always do X" rules | Reference material, invocable workflows |

**Rule of thumb:** Put it in CLAUDE.md if Claude should always know it. Put it in a skill if it's reference material Claude needs sometimes, or a workflow you trigger with `/<name>`.

---

#### D.2 — Skills

**What it is:** A markdown file containing reusable knowledge, instructions, or workflows that Claude can draw on. Skills follow the open [Agent Skills](https://agentskills.io) standard for cross-tool compatibility.

**Track:** Both (General and Developer — with different setup paths)

**Two types of skill:**
- **Reference skills** provide knowledge Claude uses throughout your session (e.g., your API style guide, brand voice guidelines)
- **Action skills** tell Claude to do something specific when invoked (e.g., `/deploy` runs your deployment workflow, `/review` runs your code review checklist)

**When to use it:**
- Reusable reference material (brand guidelines, API docs, coding standards)
- Repeatable workflows (deployment, code review, session handoff)
- Specialist knowledge Claude should have access to but doesn't need every session
- Any instruction set you want to share across team members

**How it works on each platform:**

*General users (claude.ai / Claude Desktop):*
- Skills are invoked automatically via natural language — Claude reads the skill's description and decides when to apply it
- There is no slash command — simply describe your task naturally (e.g., "I need to write a client email in our brand voice") and Claude matches it to the relevant skill
- Upload skills individually via Settings > Capabilities > Skills (ZIP format)
- Or, have your admin deploy skills to the whole team via the admin console (recommended — zero action required from end users)
- Skills from the Skills Directory (pre-built skills from Notion, Canva, Figma, Atlassian, etc.) can be installed in a few clicks

*Developers (Claude Code):*
- Skills are filesystem-based, stored in `.claude/skills/` as directories containing a `SKILL.md` file
- Invoke explicitly with `/skill-name` or let Claude auto-load based on task relevance
- Scope: Personal (`~/.claude/skills/`), Project (`.claude/skills/`), Plugin-provided
- Legacy `.claude/commands/` path still works but skills take precedence on name collision

**Skill file structure (Developer track):**
```
.claude/skills/
  my-skill/
    SKILL.md        # Required: frontmatter + instructions
    references/     # Optional: supporting files
      api-docs.md
      examples.md
```

**Key frontmatter options (Developer track):**

| Field | Purpose | Example |
|-------|---------|---------|
| `name` | Skill identifier | `session-handoff` |
| `description` | How Claude decides when to use it. Use `WHEN` / `WHEN NOT` pattern. | `WHEN the user wants to hand off a session...` |
| `disable-model-invocation` | Hides from Claude until manually invoked | `true` — saves context, ensures only you trigger it |
| `user-invocable` | Whether it appears in the `/` menu | `false` — only Claude can invoke |
| `context` | Execution context | `fork` — runs in isolated subagent context |
| `allowed-tools` | Restricts tool access when active | `["Read", "Grep", "Glob"]` |
| `model` | Override model when skill is active | `haiku` for lightweight tasks |
| `argument-hint` | Autocomplete hint | `<file-path>` |

**How it loads (context cost):**
- At session start: only skill names and descriptions load (low cost)
- When used: full SKILL.md content loads into conversation
- `disable-model-invocation: true` reduces cost to zero until manually invoked
- Description budget: 2% of context window (fallback 16,000 chars). Overridable via `SLASH_COMMAND_TOOL_CHAR_BUDGET`

**Admin-provisioned skills (General + Developer):**
- Teams admin uploads skills via the admin console
- Skills automatically appear in all users' Settings > Capabilities
- Admin can set skills as enabled-by-default
- Individual users can toggle skills on/off
- Recommended approach for Phew! — deploy skills once, available to everyone

---

#### D.3 — MCP (Model Context Protocol)

**What it is:** A protocol for connecting Claude to external services and data sources. MCP servers expose tools that Claude can call — query a database, post to Slack, control a browser.

**Track:** Both (General gets "Connectors" framing; Developer gets full MCP detail)

**When to use it:**
- Claude needs to interact with an external system (database, API, browser, project management tool)
- You want Claude to have access to real-time data, not just what's in the conversation
- You need Claude to take actions in external tools (post messages, create tickets, deploy code)

**General track framing (Connectors):**
- On claude.ai, MCP is presented as "Connectors" — pre-built, managed connections to services
- Available Connectors include Google Drive, Notion, Slack, and others
- Your admin manages which Connectors are available to the team
- No technical setup required — browse available Connectors in your settings

**Developer track detail:**
- Configure MCP servers in `.claude/settings.json` or `.mcp.json`
- Each server's tool definitions and JSON schemas load at session start
- Tool search (enabled by default) loads MCP tools up to 10% of context, deferring the rest
- MCP tool naming convention: `mcp__<server>__<tool>`
- Scope precedence: local > project > user

**How it loads (context cost):**
- All tool definitions and schemas load at session start
- Tool search caps at 10% of context, deferring the rest until needed
- **Cost guidance:** Disconnect servers you're not actively using. Run `/mcp` to see token costs per server.

**Reliability note:**
- MCP connections can fail silently mid-session
- If a server disconnects, its tools disappear without warning
- Claude may try to use a tool that no longer exists
- Check connection status with `/mcp` if Claude fails to use a tool it previously could access

**MCP vs Skills:**

| Aspect | MCP | Skill |
|--------|-----|-------|
| What it is | Protocol for connecting to external services | Knowledge, workflows, reference material |
| Provides | Tools and data access | Knowledge, workflows, reference material |
| Examples | Slack integration, database queries, browser control | Code review checklist, deploy workflow, API style guide |

These solve different problems and work well together. MCP gives Claude the ability to interact with external systems. A skill teaches Claude how to use those tools effectively. Example: an MCP server connects Claude to your database; a skill documents your data model, common query patterns, and which tables to use for different tasks.

---

#### D.4 — Subagents

**What it is:** An isolated worker that runs in its own context window, does a task, and returns only a summary to your main conversation. Like delegating to a colleague who gives you a brief report rather than showing you all their working.

**Track:** Developer only (Claude Code)

**When to use it:**
- A task requires reading many files but you only need the findings
- Your context window is getting full and you want to offload work
- You need parallel workers on independent tasks
- You want context isolation — the subagent's intermediate work doesn't clutter your session

**When to use a subagent vs other mechanisms:**

| Scenario | Use |
|----------|-----|
| Quick focused task, only result matters | Subagent |
| Workers need to communicate with each other | Agent Team |
| Reusable knowledge or workflow | Skill |
| Deterministic automation | Hook |

**Configuration options:**
- **Model selection:** `sonnet`, `opus`, `haiku`, or `inherit` (from parent)
- **Permission modes:** `default`, `acceptEdits`, `delegate`, `dontAsk`, `bypassPermissions`, `plan`
- **`maxTurns`:** Cap the number of agentic turns
- **`skills`:** Preload specific skills into the subagent's context
- **`memory`:** Enable persistent cross-session memory (`user`, `project`, or `local` scope). Memory directory with `MEMORY.md` entrypoint; first 200 lines injected into system prompt.
- **`disallowedTools`:** Deny-list specific tools
- **`mcpServers`:** Per-subagent MCP server access

**Built-in subagents:**
- **Explore** (Haiku, read-only) — lightweight research
- **Plan** (inherits model, read-only) — planning tasks
- **General-purpose** (inherits model, all tools) — standard work
- **Bash** (inherits model) — shell tasks

**How it loads (context cost):**
- Zero cost on your main context — subagents run in complete isolation
- Subagents get: system prompt, specified skills (fully preloaded), CLAUDE.md, git status, and whatever the lead agent passes in the prompt
- Subagents do NOT inherit your conversation history or invoked skills
- Auto-compaction at ~95% capacity

**Gotchas:**
- Subagents cannot spawn other subagents (no nesting)
- MCP tools are NOT available in background subagents
- Background subagents run concurrently; permission pre-approval required upfront

---

#### D.5 — Agent Teams

**What it is:** Multiple independent Claude Code sessions that coordinate via a shared task list and peer-to-peer messaging. Each teammate is a separate Claude instance with its own context.

**Track:** Developer only (Claude Code, experimental)

**When to use it:**
- Complex work requiring discussion and collaboration between workers
- Research with competing hypotheses
- Parallel code review (security + performance + tests simultaneously)
- New feature development where each teammate owns a separate piece

**When to use Agent Teams vs Subagents:**

| Aspect | Subagent | Agent Team |
|--------|----------|------------|
| Context | Own window; results return to caller | Own window; fully independent |
| Communication | Reports results back to main agent only | Teammates message each other directly |
| Coordination | Main agent manages all work | Shared task list with self-coordination |
| Best for | Focused tasks where only the result matters | Complex work requiring discussion |
| Token cost | Lower — results summarised back | Higher — each teammate is a separate instance |

**Transition point:** If you're running parallel subagents but hitting context limits, or if your subagents need to communicate with each other, agent teams are the natural next step.

**How to enable:**
- Set `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1` in settings.json or environment
- Display modes: in-process (Shift+Up/Down) and split panes (requires tmux or iTerm2)

**Key capabilities:**
- Task dependencies (tasks can depend on other tasks; auto-unblock on completion)
- Task claiming with file-locking (prevents race conditions)
- Plan approval (teammates can be required to plan before implementing; lead approves/rejects)
- Delegate mode (Shift+Tab) restricts lead to coordination-only tools
- New hook events: `TeammateIdle` and `TaskCompleted` for quality gates

**Known limitations (current):**
- No session resumption with in-process teammates
- Task status can lag (teammates may not mark tasks complete)
- One team per session
- No nested teams
- Lead is fixed (cannot transfer leadership)
- Split panes not supported in VS Code terminal, Windows Terminal, or Ghostty

**How it loads (context cost):**
- High — each teammate is a separate Claude instance with its own context
- Teammates inherit the lead's permission settings
- Reserve for genuinely parallel work that requires coordination

---

#### D.6 — Hooks

**What it is:** Deterministic scripts that run automatically when specific events occur in Claude Code. No AI involved — purely predictable automation.

**Track:** Developer only (Claude Code)

**When to use it:**
- You want something to happen automatically, every time, with no AI judgement
- Post-edit linting, pre-commit testing, notification sending
- Quality gates that must always run (not optional, not probabilistic)

**Three handler types:**
1. **`command`** — runs a shell command (the original type)
2. **`prompt`** — single-turn LLM evaluation (returns `{ok: true/false}`) — useful for judgement-based quality gates without writing scripts
3. **`agent`** — multi-turn subagent with tool access (Read, Grep, Glob) — useful for more complex evaluation that needs to read files

**Event list (14 events):**
| Event | When it fires | Matcher |
|-------|--------------|---------|
| `SessionStart` | Session begins | startup/resume/clear/compact |
| `UserPromptSubmit` | User sends a message | -- |
| `PreToolUse` | Before a tool runs | tool name |
| `PermissionRequest` | Permission prompt shown | tool name |
| `PostToolUse` | After a tool completes | tool name |
| `PostToolUseFailure` | After a tool fails | tool name |
| `Notification` | Notification sent | notification type |
| `SubagentStart` | Subagent spawns | agent type |
| `SubagentStop` | Subagent finishes | agent type |
| `Stop` | Agent stops | -- |
| `TeammateIdle` | Teammate becomes idle | -- |
| `TaskCompleted` | Task marked complete | -- |
| `PreCompact` | Before compaction | manual/auto |
| `SessionEnd` | Session ends | reason |

**How it loads (context cost):**
- Zero — hooks run as external scripts outside the agentic loop
- Exception: if a hook returns output, that output gets added as messages to your conversation

**Key features:**
- `async: true` runs hooks in background without blocking
- Exit code semantics: 0 = success, 2 = blocking error, other = non-blocking error
- JSON decision control: `permissionDecision` (allow/deny/ask), `updatedInput`, `additionalContext`
- Hot-reload protection: hooks captured at startup; mid-session modifications require review
- `disableAllHooks: true` to temporarily disable all hooks
- `/hooks` menu for interactive management

---

#### D.7 — Plugins

**What it is:** Packaging layer that bundles skills, hooks, subagents, MCP servers, and LSP servers into a single installable unit. Useful when you want to reuse the same setup across multiple repositories or distribute to others.

**Track:** Developer only (Claude Code)

**When to use it:**
- Sharing a set of extensions across multiple projects
- Distributing tools to other developers
- Packaging a complete workflow (skill + hook + MCP config) as a single install

**Plugin structure:**
```
my-plugin/
  .claude-plugin/
    plugin.json     # Manifest (name, description, version, author)
  commands/          # Skills as markdown
  skills/            # Agent Skills with SKILL.md
  agents/            # Custom agent definitions
  hooks/             # hooks.json
  .mcp.json          # MCP server configs
  .lsp.json          # LSP server configs (new)
```

**Plugin manifest fields:** name, description, version, author, homepage, repository, license, keywords

**Namespacing:** Plugin skills are namespaced (e.g., `/my-plugin:review`) so multiple plugins can coexist without name collisions

**Marketplaces:**
- Official Anthropic marketplace (`claude-plugins-official`) is built-in and auto-available
- Community marketplaces available (ClaudePluginHub, Claude-Plugins.dev)
- Marketplaces can be GitHub repos, Git URLs, local paths, or remote URLs
- Installation scopes: User, Project, Local, Managed
- Auto-updates configurable per marketplace
- Enterprise: `strictKnownMarketplaces` setting restricts allowed marketplace sources

**LSP plugins (Language Server Protocol):**
- A new plugin component type that gives Claude real-time code intelligence
- Automatic diagnostics after every file edit (type errors, missing imports, syntax issues)
- Code navigation: jump to definitions, find references, hover type info, list symbols
- Official plugins for 11+ languages: TypeScript, Python, Rust, Go, Java, Kotlin, C/C++, PHP, Ruby, C#, Swift
- Community plugins for additional languages: Bash, Clojure, Dart, Elixir, Gleam, Lua, and others
- Configured via `.lsp.json` in plugin root

**Plugin management:**
- `/plugin` menu with Discover, Installed, Marketplaces, Errors tabs
- `claude plugin validate .` or `/plugin validate .` for validation
- `--plugin-dir` flag for local testing during development
- Official plugin categories: Code intelligence, External integrations, Development workflows, Output styles

---

### E. Context Cost Summary Table

Present as a clear reference table — users will return to this.

| Feature | When it loads | What loads | Context cost | Mitigation |
|---------|--------------|------------|--------------|------------|
| **CLAUDE.md** | Session start | Full content | Every request | Keep under ~500 lines |
| **Skills (model-invocable)** | Session start + when used | Descriptions at start; full content when used | Low baseline (descriptions every request) | Use `disable-model-invocation: true` for manual-only skills |
| **Skills (manual-only)** | When invoked | Full content | Zero until invoked | Best for side-effect skills |
| **MCP servers** | Session start | All tool definitions and schemas | Up to 10% of context (with tool search) | Disconnect unused servers; check with `/mcp` |
| **Subagents** | When spawned | Fresh isolated context with specified skills | Zero on main context | Use for verbose/exploratory work |
| **Hooks (command)** | On trigger | Nothing (runs externally) | Zero | Ideal for side effects |
| **Hooks (prompt/agent)** | On trigger | Small per-invocation cost | Low | Use for judgement-based quality gates |
| **Agent Teams** | When started | N separate full contexts | High (each teammate is a separate instance) | Reserve for genuinely parallel work |

---

### F. Feature Combination Patterns

Brief section showing how extensions work together. Present as compact cards or a small table.

| Pattern | How it works | Example |
|---------|-------------|---------|
| **Skill + MCP** | MCP provides the connection; a skill teaches Claude how to use it well | MCP connects to your database; a skill documents your data model and query patterns |
| **Skill + Subagent** | A skill spawns subagents for parallel work | `/review` skill kicks off security, performance, and style subagents working in isolated context |
| **CLAUDE.md + Skills** | CLAUDE.md holds always-on rules; skills hold reference material loaded on demand | CLAUDE.md says "follow our API conventions"; a skill contains the full API style guide |
| **Hook + MCP** | A hook triggers external actions through MCP | Post-edit hook sends a Slack notification when Claude modifies critical files |
| **Skill + Subagent Memory** | A subagent with persistent memory builds institutional knowledge over time | A code review subagent remembers patterns from previous reviews and improves its suggestions |

---

### G. Feature Layering Rules (Developer Track Only)

Brief explanation of what happens when the same feature exists at multiple levels (user, project, plugin, managed).

- **CLAUDE.md files:** Additive — all levels contribute. Subdirectory files discovered as you work.
- **Skills and subagents:** Override by name — managed > user > project (for skills); managed > CLI flag > project > user > plugin (for subagents).
- **MCP servers:** Override by name — local > project > user.
- **Hooks:** Merge — all registered hooks fire for their matching events regardless of source.

---

## Interaction Design

### Decision Tree Component

**Pattern:** Accordion-wizard hybrid (from app-tech-stack.md, Section 3)

**Implementation:**
- Use shadcn `Accordion` component with `type="single" collapsible` (one item open at a time to maintain focus)
- Each top-level accordion item is an "I want to..." entry point
- Expanding an item reveals:
  - The recommended mechanism(s) as styled cards/badges
  - A 2-3 sentence explanation
  - Platform availability indicators (small badges: "claude.ai", "Desktop", "Code", "CoWork")
  - A "Learn more" link/button that scrolls to the relevant reference card further down the page
- Use Motion (`motion/react`) for smooth expand/collapse animation on the accordion content

**Track adaptation:**
- On the General track, show only Entry Points 1-4 (the mechanisms available on claude.ai and Desktop)
- On the Developer track, show all 9 entry points
- Use the `tracks` content-as-data pattern: each entry point has a `tracks: ('general' | 'developer')[]` property, and the component filters based on the current route's track parameter

**Responsive behaviour:**
- Accordion is naturally mobile-friendly — works on all screen sizes with zero layout issues
- On mobile, accordion items stack vertically (default behaviour)
- On wider screens (lg:), consider a two-column layout with the accordion on the left and the expanded detail on the right — but only if it enhances usability. Default to single-column if in doubt.

### Availability Matrix Component

**Implementation:**
- Use a standard HTML table with shadcn styling
- On mobile: allow horizontal scroll within the table container (use shadcn `ScrollArea` with horizontal scrolling)
- Use checkmark (lucide `Check` icon) and dash (lucide `Minus` icon) for visual clarity
- Colour-code: green tint for available, muted for unavailable
- Add tooltips on cells with qualifications (e.g., "Connectors (managed)" gets a tooltip explaining what that means)

### Reference Cards

**Implementation:**
- Use shadcn `Accordion` for the reference cards section (separate from the decision tree accordion above)
- Each mechanism is an accordion item with:
  - The mechanism name as the trigger
  - A structured content area inside: description, when to use, context cost, setup steps, comparison table (where applicable)
- Within each card, use shadcn `Tabs` for sub-sections if there are clearly distinct content areas (e.g., "General Setup" / "Developer Setup" tabs within the Skills card)
- Use shadcn `Alert` for important warnings or gotchas
- Use shadcn `Badge` for platform indicators
- Use the `CodeBlock` component (react-shiki) for any code examples, with `CopyButton` absolutely positioned

### Context Cost Table

**Implementation:**
- Standard table with shadcn styling
- Highlight the "Context cost" column with background tinting to draw attention
- Use colour coding: green = low/zero, amber = moderate, red = high

### Comparison Tables

**Implementation:**
- Use shadcn-styled tables within the reference cards
- Keep tables compact — avoid spanning full width on desktop
- On mobile, tables should be horizontally scrollable

### Page Structure (Scroll Order)

1. Section introduction
2. Decision tree accordion ("I want to...")
3. Platform availability matrix
4. Reference cards (expandable)
5. Context cost summary table
6. Feature combination patterns
7. Feature layering rules (Developer track only)

Use anchor links from the decision tree to the reference cards, and a sticky or in-section "Jump to" navigation for quick access to sub-sections.

---

## Copyable Content

Every copyable block must have a copy-to-clipboard button using the `CopyButton` component.

### Example 1: CLAUDE.md Template (Developer Track)

```markdown
# Project: [Project Name]

## Build Commands
- `npm run dev` — start local dev server
- `npm run build` — production build
- `npm run test` — run test suite

## Conventions
- UK English in all comments, documentation, and user-facing strings
- Use TypeScript strict mode
- Prefer functional components with hooks
- CSS: Tailwind utility classes only

## Architecture
- See `/docs/architecture/` for system architecture
- See `/docs/conventions/` for coding standards
- See `/docs/schemas/` for database schemas

## Key Rules
- Never deploy to production without passing tests
- Never commit API keys or secrets
- Always create a new branch for feature work
```

### Example 2: Skill File (Developer Track)

```markdown
---
name: session-handoff
description: |
  WHEN the user wants to hand off a conversation to another team member,
  summarise a session for continuation, or create a briefing for the next person.
  WHEN NOT the user is simply asking for a summary of the current conversation.
---

# Session Handoff

Create a structured handoff document that enables another team member (or a future
session) to continue this work without losing context.

## Output Format

Produce a markdown document with:

1. **Context** — What was being worked on and why
2. **Current state** — What has been completed, what is in progress
3. **Key decisions** — Important choices made and the reasoning
4. **Next steps** — What needs to happen next, in priority order
5. **Open questions** — Unresolved issues or areas needing input
6. **Files modified** — List of files changed during this session

## Guidelines

- Be specific — include file paths, function names, and line numbers where relevant
- Explain the "why" behind decisions, not just the "what"
- Flag any risks or concerns for the next person
- Keep it concise — aim for a document someone can read in 2-3 minutes
```

### Example 3: UK English Skill (Both Tracks)

```markdown
---
name: uk-english
description: >
  Enforce UK English spelling, grammar, and conventions in all output.
  Use when writing, reviewing, or editing any content for UK audiences.
---

# UK English

All output must use UK English spelling, grammar, and conventions.

## Spelling Rules

Use British English spellings throughout:
- -ise endings (not -ize): organise, recognise, specialise, optimise
- -our endings (not -or): colour, behaviour, favour, honour
- -re endings (not -er): centre, metre, theatre
- -ence endings: licence (noun), defence, offence
- Double L: travelling, modelling, labelling, cancelled
- Other: grey (not gray), programme (not program, unless computer program)

## Formatting Conventions

- Dates: DD/MM/YYYY or DD Month YYYY
- Currency: use £ symbol (e.g., £500, not $500)
- Time: 24-hour format preferred (e.g., 14:00)
- Single quotes for primary quotation
```

### Example 4: MCP Configuration Snippet (Developer Track)

```json
{
  "mcpServers": {
    "deepwiki": {
      "command": "npx",
      "args": ["-y", "@anthropic/deepwiki-mcp"]
    }
  }
}
```

### Example 5: Hook Configuration Snippet (Developer Track)

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "npm run lint -- --fix $TOOL_INPUT_PATH"
          }
        ]
      }
    ]
  }
}
```

### Example 6: Natural Language Skill Trigger Guidance (General Track)

```text
To use your skills on claude.ai or Claude Desktop:

You DON'T need to type a command. Simply describe what you want:

  "I need to write a client proposal in our brand voice"
  → Claude automatically loads your brand-voice skill

  "Review this document for UK English"
  → Claude automatically loads your uk-english skill

  "Create a session handoff for the next person"
  → Claude automatically loads your session-handoff skill

The better the skill's description matches your request,
the more reliably Claude will load the right skill.
```

---

## Two-Track Considerations

### General Track (claude.ai / Claude Desktop users)

**Show:**
- Decision tree entry points 1-4 only (rules, knowledge, workflows, external connections)
- Skills as the primary extension mechanism — emphasise natural language invocation, admin-provisioned deployment, ZIP upload
- Projects with custom instructions as the simplest option for persistent context
- Connectors (managed MCP) for external service connections
- The availability matrix (full — helps users understand what exists even if they can't use it all)
- Context cost table (simplified — focus on skills and MCP/Connectors)
- Copyable content: natural language trigger guidance (Example 6), UK English skill (Example 3)

**Hide:**
- Entry points 5-9 (subagents, agent teams, hooks, plugins, LSP)
- CLAUDE.md reference card (replace with Projects guidance)
- All developer-specific configuration details (frontmatter options, filesystem paths, JSON configs)
- Feature layering rules
- Hook event list
- Plugin structure

**Tone:** Focus on outcomes ("I want to..."), not technical mechanisms. Use analogies: skills are like "reference manuals you give to a colleague", MCP is like "connecting Claude to your other tools". Avoid jargon: don't say "context window" — say "Claude's working memory" or similar.

### Developer Track (Claude Code users)

**Show:** Everything. All 9 entry points, all reference cards, full configuration detail, all copyable examples, feature layering rules, gotchas.

**Additional developer-specific content:**
- Skill frontmatter options table
- Subagent configuration options
- Hook event list and handler types
- Plugin structure and marketplace ecosystem
- LSP plugins
- Feature layering rules
- All code/config examples (Examples 1-5)

**Tone:** Technical and precise. Developers want specifics — exact field names, file paths, configuration snippets. Include gotchas and edge cases (e.g., "MCP tools are NOT available in background subagents").

---

## Acceptance Criteria

### Content Completeness
- [ ] All 9 extension mechanisms covered: CLAUDE.md, Skills, MCP, Subagents, Agent Teams, Hooks, Plugins, LSP, Projects (as the General-track equivalent of CLAUDE.md)
- [ ] Decision tree includes all entry points listed in Content Outline section B
- [ ] Platform availability matrix matches the table in Content Outline section C
- [ ] Context cost table matches Content Outline section E
- [ ] All comparison tables included (CLAUDE.md vs Skills, Subagents vs Agent Teams, MCP vs Skills)
- [ ] Feature combination patterns included
- [ ] Feature layering rules included (Developer track)

### Interaction
- [ ] Decision tree is an interactive accordion-wizard hybrid using shadcn Accordion
- [ ] Expanding a decision tree entry point shows recommendation, explanation, platform badges, and link to reference card
- [ ] Reference cards are expandable accordion sections
- [ ] Availability matrix is a responsive table with horizontal scroll on mobile
- [ ] Context cost table uses colour coding for cost levels
- [ ] Smooth expand/collapse animations using Motion
- [ ] Anchor links from decision tree to reference cards work correctly

### Two-Track Behaviour
- [ ] General track shows only entry points 1-4 in the decision tree
- [ ] Developer track shows all 9 entry points
- [ ] General track hides developer-only reference cards (CLAUDE.md, Subagents, Agent Teams, Hooks, Plugins)
- [ ] General track replaces CLAUDE.md guidance with Projects guidance
- [ ] General track uses non-technical language and analogies
- [ ] Developer track includes full configuration detail, code examples, and gotchas

### Copyable Content
- [ ] Every code block, configuration snippet, and template has a copy-to-clipboard button
- [ ] All 6 copyable examples from the spec are present
- [ ] Copy feedback (icon switch to checkmark for 2 seconds) works

### Accessibility
- [ ] Accordion uses proper `aria-expanded`, `aria-controls` associations (shadcn handles this)
- [ ] Tables have proper header markup and are navigable by screen reader
- [ ] Platform badges have accessible text (not just colour)
- [ ] All interactive elements keyboard-navigable (Tab, Enter, Escape, Arrow keys)
- [ ] `prefers-reduced-motion` respected on accordion and card animations

### Content Quality
- [ ] UK English throughout (spelling, grammar, conventions)
- [ ] Tone is practical and non-condescending — appropriate for a UK SMB audience
- [ ] Examples are contextually relevant to Phew! (safeguarding/public sector design agency context)
- [ ] No enterprise jargon
- [ ] Key warnings and gotchas are clearly flagged (e.g., experimental status of Agent Teams, MCP silent failures)

---

## Build Agent Checklist

### Frontend Quality Checklist

**Typography**
- [ ] Body text >= 16px (1rem), using rem units
- [ ] Max line length: 65ch for body text
- [ ] Fluid type (clamp) on headings; fixed sizes on UI controls
- [ ] Font stacks include size-adjusted fallback
- [ ] No generic fonts (Inter, Roboto, etc.) unless explicitly specified

**Colour & Theming**
- [ ] All custom colours defined in OKLCH via CSS variables
- [ ] Neutrals tinted towards brand hue (not pure grey)
- [ ] No pure black (#000) or pure white (#fff)
- [ ] Dark mode tested and functional (if applicable to section)
- [ ] All text meets WCAG AA contrast (4.5:1 body, 3:1 large/UI)

**Layout & Spacing**
- [ ] Spacing values from the 4pt grid (4, 8, 12, 16, 24, 32, 48, 64, 96)
- [ ] Visual hierarchy uses 2+ dimensions (size, weight, colour, space)
- [ ] No nested cards
- [ ] No identical repeating card grids

**Motion & Animation**
- [ ] Only `transform` and `opacity` animated (no width/height/top/left)
- [ ] Timing follows 100/300/500 rule
- [ ] Easing uses exponential curves (not default `ease` or bounce)
- [ ] `prefers-reduced-motion` handled (crossfade fallback or disable)
- [ ] Exit animations faster than entrances
- [ ] Motion used via Tailwind transitions where CSS suffices; Motion library only for layout/enter/exit

**Interaction**
- [ ] All 8 interactive states designed (default, hover, focus, active, disabled, loading, error, success)
- [ ] `:focus-visible` ring on all interactive elements (2-3px, offset, 3:1 contrast)
- [ ] Touch targets >= 44px
- [ ] Copy-to-clipboard on every prompt/template/code block
- [ ] Skeleton screens for loading states (not generic spinners)

**Accessibility**
- [ ] Semantic HTML (headings, landmarks, labels)
- [ ] Skip link present
- [ ] Keyboard navigation tested (Tab, Enter, Escape, Arrows)
- [ ] `aria-expanded`, `aria-controls` on accordions/collapsibles
- [ ] `aria-label` on icon-only buttons
- [ ] Images have `alt` text (or `alt=""` for decorative)
- [ ] Never `outline: none` without `:focus-visible` replacement

**Performance**
- [ ] No barrel file imports (direct imports from source)
- [ ] Shiki lazy-loaded (not in initial bundle)
- [ ] Derived state computed during render (no useEffect for derived values)
- [ ] `content-visibility: auto` on long scrollable content
- [ ] Passive event listeners on scroll/touch handlers
- [ ] Static JSX hoisted outside components where possible

**Responsive**
- [ ] Mobile-first (base styles for mobile, min-width queries for larger)
- [ ] Tested at 320px, 640px, 768px, 1024px widths
- [ ] No critical functionality hidden on mobile
- [ ] Hover-dependent features have touch alternatives
- [ ] Safe area insets handled for mobile

**UX Writing & Content**
- [ ] UK English throughout (spelling, grammar, currency, date format)
- [ ] Button labels use verb + object pattern
- [ ] Error messages answer: what, why, how to fix
- [ ] Consistent terminology (no synonyms for the same action)
- [ ] Empty states are actionable, not just "Nothing here"

**Code Quality**
- [ ] Tailwind utility classes only (no CSS modules or styled-components)
- [ ] `cn()` utility for conditional class merging
- [ ] `@/` path alias for all imports
- [ ] Components composed from shadcn primitives (not mega-components)
- [ ] Content defined as typed TS objects, not hard-coded JSX
