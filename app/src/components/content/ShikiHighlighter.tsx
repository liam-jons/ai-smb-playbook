import { useState, useEffect } from 'react';
import { createHighlighterCore } from 'shiki/core';
import { createJavaScriptRegexEngine } from 'shiki/engine/javascript';
import type { HighlighterCore } from 'shiki/core';
import { cn } from '@/lib/utils';

// Explicit static imports — only these languages and themes will be bundled.
// This prevents Vite from discovering and code-splitting all 300+ Shiki grammars.
import langMarkdown from 'shiki/langs/markdown.mjs';
import langBash from 'shiki/langs/bash.mjs';
import langJson from 'shiki/langs/json.mjs';
import themeGithubLight from 'shiki/themes/github-light.mjs';
import themeGithubDark from 'shiki/themes/github-dark.mjs';

const SUPPORTED_LANGS = ['markdown', 'bash', 'json', 'text'] as const;
const SUPPORTED_THEMES = [
  'github-light',
  'github-dark',
  'vitesse-dark',
  'dracula-soft',
  'min-light',
  'min-dark',
] as const;

// Lazy theme loaders for creative themes — only fetched when a creative theme is active
const lazyThemeImports: Record<string, () => Promise<unknown>> = {
  'vitesse-dark': () => import('shiki/themes/vitesse-dark.mjs'),
  'dracula-soft': () => import('shiki/themes/dracula-soft.mjs'),
  'min-light': () => import('shiki/themes/min-light.mjs'),
  'min-dark': () => import('shiki/themes/min-dark.mjs'),
};

const loadedThemes = new Set<string>(['github-light', 'github-dark']);

let highlighterPromise: Promise<HighlighterCore> | null = null;

function getHighlighter(): Promise<HighlighterCore> {
  if (!highlighterPromise) {
    highlighterPromise = createHighlighterCore({
      langs: [langMarkdown, langBash, langJson],
      themes: [themeGithubLight, themeGithubDark],
      engine: createJavaScriptRegexEngine(),
    });
  }
  return highlighterPromise;
}

async function ensureThemeLoaded(themeName: string): Promise<void> {
  if (loadedThemes.has(themeName)) return;
  const highlighter = await getHighlighter();
  const loader = lazyThemeImports[themeName];
  if (loader) {
    const themeModule = await loader();
    // The theme module default export is the theme object
    await highlighter.loadTheme(
      themeModule as Parameters<typeof highlighter.loadTheme>[0],
    );
    loadedThemes.add(themeName);
  }
}

interface ShikiHighlighterProps {
  code: string;
  language: string;
  theme: string;
  showLineNumbers?: boolean;
}

export function ShikiHighlighter({
  code,
  language,
  theme,
  showLineNumbers = false,
}: ShikiHighlighterProps) {
  const [html, setHtml] = useState<string>('');

  useEffect(() => {
    let cancelled = false;

    async function highlight() {
      // Ensure the requested theme is loaded (no-op for eagerly loaded defaults)
      const resolvedTheme = (SUPPORTED_THEMES as readonly string[]).includes(
        theme,
      )
        ? theme
        : 'github-light';

      await ensureThemeLoaded(resolvedTheme);
      if (cancelled) return;

      const highlighter = await getHighlighter();
      if (cancelled) return;

      // Fall back to 'text' for any unsupported language
      const lang = (SUPPORTED_LANGS as readonly string[]).includes(language)
        ? language
        : 'text';

      const result = highlighter.codeToHtml(code, {
        lang,
        theme: resolvedTheme,
      });

      if (!cancelled) {
        setHtml(result);
      }
    }

    highlight();

    return () => {
      cancelled = true;
    };
  }, [code, language, theme]);

  // Safety note: dangerouslySetInnerHTML is intentional here. The HTML is
  // generated by Shiki from developer-controlled code snippets defined in
  // the app's own data files — there is no user-supplied content involved.
  return (
    <div
      className={cn(
        'overflow-x-auto [&_pre]:p-4 [&_pre]:text-sm [&_pre]:leading-relaxed [&_pre]:!bg-transparent',
        showLineNumbers &&
          '[&_.line]:before:mr-4 [&_.line]:before:text-muted-foreground/40',
      )}
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
}
